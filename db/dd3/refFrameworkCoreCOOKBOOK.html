<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: Core COOKBOOK</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('db/dd3/refFrameworkCoreCOOKBOOK.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Core COOKBOOK </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Data Processing Layer Cookbook</h1>
<p>This is a work in progress entrypoint for common DPL related tasks.</p>
<h4>Utilities for working with <code>DataRef</code></h4>
<p>Get payload size: </p><div class="fragment"><div class="line"><span class="keywordtype">size_t</span> payloadSize = DataRefUtils::getPayloadSize(<a class="code" href="../../dc/da3/glcorearb_8h.html#ad32bdec748ba376f6c0d2df39ab9a95b">ref</a>);</div></div><!-- fragment --><p>Extract a header from the header stack: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="../../de/dd4/namespaceo2_1_1header.html#a57d31ff7c9656164cbca87006e9b7972">HeaderType</a>* header = DataRefUtils::getHeader&lt;HeaderType*&gt;(<a class="code" href="../../dc/da3/glcorearb_8h.html#ad32bdec748ba376f6c0d2df39ab9a95b">ref</a>);</div></div><!-- fragment --><p>Get the payload of messageable type as <code>gsl::span</code> </p><div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="../../dc/da3/glcorearb_8h.html#a8922a680b00df660c57f47c1971d04c5">data</a> = DataRefUtils::as&lt;T&gt;(<a class="code" href="../../dc/da3/glcorearb_8h.html#ad32bdec748ba376f6c0d2df39ab9a95b">ref</a>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; element : <a class="code" href="../../dc/da3/glcorearb_8h.html#a8922a680b00df660c57f47c1971d04c5">data</a>) {</div><div class="line">  <span class="comment">// do something on element, remember it&#39;s const</span></div><div class="line">}</div></div><!-- fragment --><h4>How do I report failure for a given Algorithm?</h4>
<p>Whenever the driver process spots an error message, i.e. an error printed via <code><a class="el" href="../../df/d5b/GPUCommonLogger_8h.html#aea3d0edfe28fc0325c636b2b33f0527a">LOG(ERROR)</a></code> facility, when the driver process quits, it will exit with a exit code of 1. This includes any exception reported by the default exception handler.</p>
<p>This comes handy, for example in tests.</p>
<h3>Debugging on your laptop</h3>
<p>The way the DPL currently works is that the driver executable you launch, will then take care of spawning one device per <code>DataProcessorSpec</code> in a separate process. This means that in order to debug your code you need to make sure gdb / lldb are actually debugging the right child process.</p>
<p>For <code>gdb</code> you can use the <code>follow-fork-mode</code> setting. See <a href="https://sourceware.org/gdb/onlinedocs/gdb/Forks.html">here</a> for the full documentation. This is unfortunately not available in <a href="https://bugs.llvm.org/show_bug.cgi?id=17972">lldb</a>.</p>
<p>Alternatively you can start your driver executable with the <code>-s</code> / <code>--stop</code> command line option which will immediately stop execution of the children after the fork, allowing you to attach to them, e.g. for gdb using:</p>
<div class="fragment"><div class="line">attach &lt;pid&gt;</div></div><!-- fragment --><p>or the <code>lldb</code> equivalent:</p>
<div class="fragment"><div class="line">attach -pid &lt;pid&gt;</div></div><!-- fragment --><p> Note: On some systems, attaching might fail due to missing permission, and <code>gdb</code> has to be started with <code>sudo</code>.</p>
<p>In case you are building the DPL with the support for the debug GUI, you can also attach a debugger to the running process by clicking on the DataProcessorSpec you want to debug, which will show the Device inspector on the right, and there click on the "Attach debugger" button. By default this will start lldb in a Terminal.app window on mac, or GDB in an xterm elsewhere. You can customise this behavior by setting the environment variable <code>O2DPLDEBUG</code> to the command you want to run for the debugger and use the environment variable <code>O2DEBUGGEDPID</code> to get the PID of the DataProcessor currently selected. You can do this multiple times for all the devices you wish to debug, but remember that you will need to quit the debugger if you want DPL to exit.</p>
<p>On linux you might need to start the debugger with <code>sudo</code> to have the permission to attach, e.g. set O2DPLDEBUG to </p><div class="fragment"><div class="line">export O2DPLDEBUG=&#39;xterm -hold -e sudo gdb attach $O2DEBUGGEDPID &amp;&#39;</div></div><!-- fragment --><p> Be sure to use single quotes to avoid direct expansion of O2DEBUGGEDPID variable. The <code>&amp;</code> character add the end is needed to start gdb in a separate process.</p>
<h3>Debug GUI</h3>
<p>The demonstator also includes a simple GUI to help debugging problems:</p>
<div class="image">
<img src="https://user-images.githubusercontent.com/10544/29307499-75bb8550-81a2-11e7-9aa6-96b7613288b5.png"/>
</div>
<p>The GUI provides the following facilities:</p>
<ul>
<li>Graph view with all the connections between DataProcessors</li>
<li>One log window per DataProcessor, allowing filtering and triggering on log messages</li>
<li>Metrics inspector</li>
</ul>
<h3>Integrating with non-DPL devices</h3>
<p>Given the Data Processing Layer comes somewhat later in the design of O2, it's possible that you already have some topology of devices which you want to integrate, without having to port them to the DPL itself. Alternatively, your devices might not satisfy the requirements of the Data Processing Layer and therefore require a "raw" <code><a class="el" href="../../db/dfe/classFairMQDevice.html">FairMQDevice</a></code>, fully customised to your needs. This is fully supported and we provide means to ingest foreign, non-DPL FairMQDevices produced, messages into a DPL workflow. This is done via the help of a "proxy" data processor which connects to the foreign device, receives its inputs, optionally converts them to a format understood by the Data Processing Layer, and then pumps them to the right Data Processor Specs. In order to have such a device in your workflow, you can use the [<code>specifyExternalFairMQDeviceProxy</code>][specifyExternalFairMQDeviceProxy] helper to instanciate it. For an example of how to use it you can look at [<code><a class="el" href="../../da/d19/test__RawDeviceInjector_8cxx.html">Framework/TestWorkflows/src/test_RawDeviceInjector.cxx</a></code>][rawDeviceInjectorExample]. The <code>specifyExternalFairMQDeviceProxy</code> takes four arguments:</p>
<div class="fragment"><div class="line"><a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#a4e8e6f56c5a69783879e1b697db2f39d">specifyExternalFairMQDeviceProxy</a>(<span class="stringliteral">&quot;foreign-source&quot;</span>,</div><div class="line">                {outspec},</div><div class="line">                <span class="stringliteral">&quot;type=sub,method=connect,address=tcp://localhost:5450,rateLogging=1&quot;</span>,</div><div class="line">                <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#a8c5da815907e3670cb170bc9132c3723">o2DataModelAdaptor</a>(outspec, 0, 1)</div><div class="line">               ),</div></div><!-- fragment --><p>the first one is the usual <code>DataProcessorSpec</code> name, the second one is a list of outputs which we will create from the non-DPL device, the third one is a string to connect to the existing topology and a the fourth one is a function of the kind <code><a class="el" href="../../dd/d8d/namespaceo2_1_1framework.html#ad5aec4650d00d837d3d545dff4b5f4d1">o2::framework::InjectorFunction</a></code> which does the actual conversion. In this particular case we use the <code><a class="el" href="../../dd/d8d/namespaceo2_1_1framework.html#a8c5da815907e3670cb170bc9132c3723">o2DataModelAdaptor()</a></code> helper to create such an translation function since we know that our input is already respecting the O2 Data <a class="el" href="../../d6/d18/classModel.html">Model</a> and most of the heavylifing can be done automatically.</p>
<p>Sending out the results of a computation can be done in a similar manner. Use</p>
<div class="fragment"><div class="line">ConfigParamSpec{<span class="stringliteral">&quot;channel-config&quot;</span>, VariantType::String, <span class="stringliteral">&quot;&lt;channel-configuration&gt;&quot;</span>, <span class="stringliteral">&quot;Out-of-band channel config&quot;</span>}</div></div><!-- fragment --><p>to create an out-of-band channel as specified in <code>channel-configuration</code> and hen use the <code>RawDeviceService</code> to get the raw <a class="el" href="../../db/dfe/classFairMQDevice.html">FairMQDevice</a> and send data hrough such a channel.</p>
<h2>Customizing workflows creation (WIP)</h2>
<p>Sometimes it's handy to customise or generalise the workflow creation based on external inputs. For example you might want to change the number of workers for a given task or disable part of the topology if a given detector should not be enabled.</p>
<p>This can be done by implementing the function:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/d90/trackselection_8cxx.html#a1847186994155009dc39999a652c9b3d">customize</a>(std::vector&lt;o2::framework::ConfigParamSpec&gt; &amp;workflowOptions)</div></div><!-- fragment --><p><b>before</b> including the <code>Framework/runDataProcessing.h</code> (this will most likely change in the future). Each ConfigParamSpec will be added to the configuration mechanism (e.g. the command line options) allowing you to modify them. Such options will then be made available at workflow creation time via the <code>ConfigContext</code> passed to the <code>defineDataProcessing</code> function, using the <code>ConfigContext::options()</code> getter.</p>
<h2>Completion policies (WIP)</h2>
<p>By default the data processing of a given record happens when all the fields of that record are present. So if your Data Processor declares it will consume <code>TRACKS</code> and <code>CLUSTERS</code>, for any given time interval both need to be produced by some other data processor before the computation declared in yours can happen.</p>
<p>Sometimes it's however desirable to customise such a behavior, so that some action on the record can happen even if it's not complete. For example you might want to start computing some quantity as a given message arrives and then complete the computation once the record is complete. This is done by specifying by customising the data processing CompletionPolicy. This can be done using the usual <b>Customization mechanism</b> where a:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/d90/trackselection_8cxx.html#a1847186994155009dc39999a652c9b3d">customize</a>(std::vector&lt;CompletionPolicy&gt; &amp;policies);</div></div><!-- fragment --><p>function is provided before including <code>runDataProcessing.h</code>.</p>
<p>Each <code>CompletionPolicy</code> requires the user to specify the <code>matcher</code> to select which device is affected by it, and a <code>callback</code> to decide what action expressed by a <code>CompletionOp</code> to take on a given input record.</p>
<p>Possible actions include:</p>
<ul>
<li><code>CompletionPolicy::CompletionOp::Consume</code>: run the data processing callback and mark the available fields in the input as consumed.</li>
<li><code>CompletionPolicy::CompletionOp::Process</code>: run the data processing callback, but do not consume the field, which will be available when the next message for the field</li>
<li><code>CompletionPolicy::CompletionOp::Wait</code>: hold on the record but do not process it yet.</li>
<li><code>CompletionPolicy::CompletionOp::Drop</code>: drop the current available fields from the record.</li>
</ul>
<p>The default completion policy is to consume all inputs when they are all present.</p>
<p>When the computation is dispatched with a partially completea <code>InputRecord</code>, the user can check for the validity of any of its parts via the <code>InputRecord::isValid()</code> API.</p>
<h2>Customizing deployment configuration (WIP)</h2>
<p>By default every device instanciated by the Data Processing Layer connects to the others using the PUB/SUB paradigm. This might or might not be desiderable for some or even all of the connections. For this reason there is now a way to customise the connections based on the ids of the devices being instanciated.</p>
<p>In order to do so, one needs to implement the function</p>
<div class="fragment"><div class="line"><a class="code" href="../../db/d90/trackselection_8cxx.html#a1847186994155009dc39999a652c9b3d">customize</a>(std::vector&lt;o2::framework::ChannelConfigurationPolicy&gt; &amp;policies)</div></div><!-- fragment --><p><b>before</b> including <code>Framework/runDataProcessing.h</code> (this will most likely change in the future). You can then extend the policies vector with your own <code>ChannelConfigurationPolicy</code>. For each device to device edge, the system will invoke the <code>ChannelConfigurationPolicy::match</code> callback with the ids of the producer and of the consumer as arguments. If the callback returns <code>true</code>, the <code>ChannelConfigurationPolicy::modifyInput</code> and <code>ChannelConfigurationPolicy::modifyOutput</code> will be invoked passing the input and output channel associated to the two devices, giving the opportunity to modify the matching channels.</p>
<h2>Getting objects from the CCDB</h2>
<p>In order to get objects from the CCDB one can specify the <code>Lifetime::Condition</code> for the required input spec. That will retrieve the object not from another data processor but it will do a request to a CCDB server. The actual URL for the server can be specified via the <code>--condition-backend &lt;backend-url&gt;</code> option. It is also possible to specify a given timestamp for the object via the option <code>--condition-timestamp &lt;timestamp&gt;</code>. The final url is completed by the value of the the Origin and Description of the <code>InputSpec</code> to be:</p>
<div class="fragment"><div class="line">&lt;backend-url&gt;/&lt;origin&gt;/&lt;description&gt;/&lt;timestamp&gt;</div></div><!-- fragment --><p>If the timestamp is not specified, DPL will look it up in the <code>DataProcessingHeader</code>.</p>
<h1>Future features</h1>
<h2>Lifetime support</h2>
<p>While initially foreseen in the design, Lifetime for Inputs / Outputs has not yet being implemented correctly. However, once that happens, the following behaviors will be implemented (naming foreseen to change). Once implemented it will be possible to specify the following Lifetime types:</p>
<ul>
<li>Timeframe: an input that gets processed only once.</li>
<li>Condition: an input that is cache on considered valid for multiple computations, according to its IOV.</li>
<li>Transient: an output which is not actually sent. Useful to use the same mechanism of the Message Passing API to create</li>
<li>QA: an output which once send is also proposed as input to the subsequent computation, allowing for accumulating data (e.g. histograms).</li>
<li>SubTimeframe: an input which gets processed only once which has a granularity of less than a timeframe. Within one computation multiple of these can be created. They get sent as soon as they go out of scope.</li>
</ul>
<h2>Wildcard support for InputSpec / OutputSpec</h2>
<p>In order to reduce the amount of code which one has to write to define inputs and outputs, we plan to make the InputSpecs and OutputSpecs as veritable matchers, supporting wildcards. For example if your Algorithm supports processing clusters coming from multiple detectors, it will be possible to specify:</p>
<div class="fragment"><div class="line">InputSpec{<span class="stringliteral">&quot;*&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>}</div></div><!-- fragment --><p>If the user wants to get both clusters and tracks coming from the same detector, it will be possible to write:</p>
<div class="fragment"><div class="line">InputSpec{<span class="stringliteral">&quot;*&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>}, InputSpec{<span class="stringliteral">&quot;*&quot;</span>, <span class="stringliteral">&quot;TRACKS&quot;</span>}</div></div><!-- fragment --><p>i.e. the first message which arrives will define the wildcard for all the other input spec in the definition.</p>
<h3>Data flow parallelism</h3>
<p>Data flow parallelism is simply expressed by tuning the data flow, adding explicitly the parallel data paths, using the appropriate <code>InputSpec</code> and <code>OutputSpec</code>.</p>
<p>E.g.:</p>
<div class="fragment"><div class="line">DataProcessorSpec{</div><div class="line">  <span class="stringliteral">&quot;tpc_processor_1&quot;</span>,</div><div class="line">  <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#ae0fa8f5b8c413d923205bbe985f08602">Inputs</a>{},</div><div class="line">  <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#af99101fa4f6d5dd76f39eb050f2b2d2a">Outputs</a>{{<span class="stringliteral">&quot;TPC&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>, <a class="code" href="../../d2/d23/dataSamplingBenchmark_8cxx.html#a350f3783408f572381ffe5cb7a6c449e">SubSpec</a>(0)}},</div><div class="line">  <span class="comment">// ...</span></div><div class="line">},</div><div class="line">DataProcessorSpec{</div><div class="line">  <span class="stringliteral">&quot;tpc_processor_2&quot;</span>,</div><div class="line">  <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#ae0fa8f5b8c413d923205bbe985f08602">Inputs</a>{},</div><div class="line">  <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#af99101fa4f6d5dd76f39eb050f2b2d2a">Outputs</a>{{<span class="stringliteral">&quot;TPC&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>, <a class="code" href="../../d2/d23/dataSamplingBenchmark_8cxx.html#a350f3783408f572381ffe5cb7a6c449e">SubSpec</a>(1)}},</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div><div class="line"><span class="comment">// ...</span></div><div class="line">DataProcessorSpec{</div><div class="line">  <span class="stringliteral">&quot;tpc_processor_18&quot;</span>,</div><div class="line">  <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#ae0fa8f5b8c413d923205bbe985f08602">Inputs</a>{},</div><div class="line">  <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#af99101fa4f6d5dd76f39eb050f2b2d2a">Outputs</a>{{<span class="stringliteral">&quot;TPC&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>, <a class="code" href="../../d2/d23/dataSamplingBenchmark_8cxx.html#a350f3783408f572381ffe5cb7a6c449e">SubSpec</a>(17)}},</div><div class="line">  <span class="comment">// ...</span></div><div class="line">}</div></div><!-- fragment --><p>or alternatively the parallel workflows part could be generated programmatically:</p>
<div class="fragment"><div class="line"><a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#a930799bc13c911ce05e376c5b6c8ac09">parallel</a>(</div><div class="line">  DataProcessorSpec{</div><div class="line">    <span class="stringliteral">&quot;tpc_processor&quot;</span>,</div><div class="line">    {InputSpec{<span class="stringliteral">&quot;c&quot;</span>, <span class="stringliteral">&quot;TPC&quot;</span>, <span class="stringliteral">&quot;CLUSTERS&quot;</span>}}</div><div class="line">  },</div><div class="line">  18,</div><div class="line">  [](DataProcessorSpec &amp;spec, <span class="keywordtype">size_t</span> idx) {</div><div class="line">    spec.outputs[0].subSpec = idx; <span class="comment">// Each of the 18 DataProcessorSpecs should have a different subSpec</span></div><div class="line">  }</div><div class="line">)</div></div><!-- fragment --><p>Similarly this can be done for a component that merges inputs from multiple parallel devices, this time by modifying programmatically the <code>Inputs</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div><div class="line">DataProcessorSpec{</div><div class="line">  <span class="stringliteral">&quot;merger&quot;</span>,</div><div class="line">  <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#a9ef5348ee14533cea9aeadad2c14ae91">mergeInputs</a>({<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;TST&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>, 0, Lifetime::Timeframe},</div><div class="line">              4,</div><div class="line">              [](InputSpec &amp;input, <span class="keywordtype">size_t</span> <a class="code" href="../../dc/da3/glcorearb_8h.html#a57f14e05b1900f16a2da82ade47d0c6d">index</a>) {</div><div class="line">                 input.subSpec = <a class="code" href="../../dc/da3/glcorearb_8h.html#a57f14e05b1900f16a2da82ade47d0c6d">index</a>;</div><div class="line">              }</div><div class="line">          ),</div><div class="line">  {},</div><div class="line">  AlgorithmSpec{[](InitContext &amp;setup) {</div><div class="line">     <span class="keywordflow">return</span> [](ProcessingContext &amp;ctx) {</div><div class="line">  <span class="comment">// Create a single output.</span></div><div class="line">    <a class="code" href="../../df/d5b/GPUCommonLogger_8h.html#aea3d0edfe28fc0325c636b2b33f0527a">LOG</a>(DEBUG) &lt;&lt; <span class="stringliteral">&quot;Invoked&quot;</span> &lt;&lt; std::endl;</div><div class="line">  };</div><div class="line">}</div><div class="line"><span class="comment">// ...</span></div></div><!-- fragment --><p>When one declares a parallel set of devices you can retrieve the rank (i.e. parallel id) or the number of parallel devices by using the <code>ParalleContext</code>, which can be retrieved from the <code>ServiceRegistry</code> (see also the <code>Services</code> section below), e.g.:</p>
<div class="fragment"><div class="line"><span class="keywordtype">size_t</span> whoAmI = services.get&lt;ParallelContext&gt;().index1D();</div><div class="line"><span class="keywordtype">size_t</span> howManyAreWe = services.get&lt;ParallelContext&gt;().index1DSize();</div></div><!-- fragment --><h3>Time pipelining</h3>
<p><a class="el" href="../../d2/d88/classA.html">A</a> second type of parallelism is time based pipelining. This assumes that the data can be subdivided in subsequent "time periods" that are independent one from the other and which are each identified by some timestamp entity. In this particular case it could result handy that some part of the workflow are actually processing different time periods. This can be expressed via the <code>timePipeline</code>, directive, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div><div class="line"><a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#ac23d50376a9780e817bf2f9cc67ade79">timePipeline</a>(DataProcessorSpec{</div><div class="line">  <span class="stringliteral">&quot;processor&quot;</span>,</div><div class="line">  {InputSpec{<span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;TST&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>}},</div><div class="line">  {<a class="code" href="../../d8/d32/namespaceo2_1_1cpv.html#a783918994e0c4afeda66942829d505d2">OutputSpec</a>{<span class="stringliteral">&quot;TST&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>}},</div><div class="line">  AlgorithmSpec{[](ProcessingContext &amp;ctx) {</div><div class="line">    };</div><div class="line">  }</div><div class="line">}, 2);</div><div class="line"><span class="comment">// ...</span></div></div><!-- fragment --><p>which will result in two devices, one for even time periods, the other one for odd timeperiods.</p>
<h3>Disabling monitoring</h3>
<p>Sometimes (e.g. when running a child inside valgrind) it might be useful to disable metrics which might pollute STDOUT. In order to disable monitoring you can use the <code>no-op://</code> backend:</p>
<div class="fragment"><div class="line">some-workflow --monitoring-backend=no-op://</div></div><!-- fragment --><p>notice that the GUI will not function properly if you do so.</p>
<h3>Vectorised input</h3>
<p>Sometimes data processing requires to group together multiple messages in one single multipart vector, so that they can be multiplexed on the same InputSpec. This is in particular the case for the RAW data coming out of the (Sub)TFBuilder. In order to do so you need to make sure that the sender sends all the parts to be multiplexed in a single go. On the receiving side, you will get a single entry in the InputRecord and you can get the number of combined parts via <code>InputRecord::getNoParts()</code>. You can each of the parts by providing the entra parameter parts to the <code><a class="el" href="../../de/dd4/namespaceo2_1_1header.html#a8c7ef2f932c17c130bcfb106be80d1d7">InputRecord::get()</a></code> method.</p>
<h3>Using command line options in DataProcessorSpec</h3>
<p>Command line options for a given DataProcessorSpec are defined as a std::vector&lt;ConfigParamSpec&gt;.</p>
<p><a class="el" href="../../d2/d88/classA.html">A</a> ConfigParamSpec is defined by the 4 arguments</p><ul>
<li>name</li>
<li>type</li>
<li>default</li>
<li>help</li>
</ul>
<p>or with a constructor using only 3 arguments (without the default value).</p>
<p>E.g. </p><div class="fragment"><div class="line">{ {<span class="stringliteral">&quot;opt1&quot;</span>, VariantType::String, <span class="stringliteral">&quot;def1&quot;</span>, {<span class="stringliteral">&quot;Command line option 1&quot;</span>}},    <span class="comment">// constructor with default value def1</span></div><div class="line">  {<span class="stringliteral">&quot;opt2&quot;</span>, VariantType::Int, {<span class="stringliteral">&quot;Command line option 2&quot;</span>}},               <span class="comment">// constructor without default value  </span></div><div class="line">  {<span class="stringliteral">&quot;opt3&quot;</span>, VariantType::Float, 10., {<span class="stringliteral">&quot;Command line option 3&quot;</span>}} }</div></div><!-- fragment --><p>(the available VariantType are listed in Framework/Variant.h).</p>
<p>The options are internally filled into an object of type ConfigParamRegistry and forwarded to the InitCallback of the respective AlgorithmSpec as part of the argument of type InitContext. The ConfigParamRegistry is finally accessed with InitContext::options().</p>
<p>E.g. </p><div class="fragment"><div class="line">ConfigParamRegistry opts = ic.options();  <span class="comment">// with InitContext ic;</span></div></div><!-- fragment --><p>ConfigParamRegistry has the two methods <code>isSet(key)</code> and <code>get&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;(key)</code>.</p>
<p>To read the option value use the <code>get&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code> method with the appropriate type <code><a class="el" href="../../d1/def/classT.html">T</a></code>, e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> vopt1 = ic.options().get&lt;std::string&gt;(<span class="stringliteral">&quot;opt1&quot;</span>);</div><div class="line"><span class="keyword">auto</span> vopt2 = ic.options().get&lt;<a class="code" href="../../d8/de9/qconfigoptions_8h.html#ad08a37964429d340d966dfa679443e8f">std::int</a>&gt;(<span class="stringliteral">&quot;opt2&quot;</span>);</div></div><!-- fragment --><p>To test wether the option <code>key</code> was set on the command line the method <code>isSet(key)</code> can be used. However be aware that the method <code>isSet(key)</code> with an option defined with a default value (constructor with 4 arguments) will always return <code>true</code>. If the option was set on the command line, then it will have the respective set value. If it is not set on the command line then it will have the default value. On the other hand an option defined without a default value (constructor with 3 arguments) will only be recognized as set if it indeed was set on the command line. If it was not set, then its value will be undefined. Thus to read an option without default value do e.g.</p>
<div class="fragment"><div class="line">std::string vopt1(<span class="stringliteral">&quot;&quot;</span>);</div><div class="line"><span class="keywordflow">if</span> (ic.options().isSet(<span class="stringliteral">&quot;opt1&quot;</span>)) {</div><div class="line">  vopt1 = ic.options().get&lt;std::string&gt;(<span class="stringliteral">&quot;opt1&quot;</span>);</div><div class="line">}</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d3a/refFramework.html">Module &#39;Framework&#39;</a></li><li class="navelem"><a class="el" href="../../d4/d0b/refFrameworkCore.html">Core</a></li>
    <li class="footer">Generated on Thu Jun 4 2020 09:30:40 for Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
