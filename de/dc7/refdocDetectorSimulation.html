<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: Detector Simulation</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('de/dc7/refdocDetectorSimulation.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Detector Simulation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1>Detector simulation documentation</h1>
<p>The present document collects information about the ALICE detector simulation executable and digitization procedure used in LHC Run3.</p>
<h2>Overview</h2>
<p>Detector simulation, the simulation of detector response from virtual particle events, consists of essentialy 2 parts: a) the generation of simple (energy deposit) traces in the detector due to the passage of particles and the interaction with the detector material. b) the conversion of those traces into (electronic) signals in the detector readout (usually called digitization).</p>
<p>The first part is handled by the <code>o2-sim</code> executable (See <a href="../../#SimSection">SimSection</a>). The second part is handled in the <code>o2-sim-digitizer-workflow</code> executable (See <a href="../../#DigitSection">DigitSection</a>). References to examples are <a href="../../#Examples">collected here</a>.</p>
<h2>Key new features with respect to AliRoot</h2>
<p>The Run3 simulation offers the following features</p>
<ul>
<li><b>distributed system based on FairMQ</b> that is splitting event generation, particle transport and IO into separate asyncronous components that can be deployed on different machines</li>
<li><b>sub-event parallelism</b> making it possible to transport a single big event in a short time and to reduce memory consumption</li>
<li><b>parallelism</b> independent on transport engine</li>
<li><b>configuration via pre-defined parameter classes and ini/text files</b></li>
<li><b>clear separation of transport and digitization</b> - each phase can be run fully independently</li>
</ul>
<h1>Documentation of transport simulation <a class="anchor" id="SimSection"></a></h1>
<p>The purpose of the <code>o2-sim</code> executable is to simulate the passage of particles emerging from a collision inside the detector and to obtain their effect in terms of energy deposits (called hits) which could be converted into detectable signals. It is the driver executable which will spawn a topology of sub-processes that interact via messages in a distributed system.</p>
<h2>Usage overview</h2>
<ul>
<li><p class="startli"><b>Quick start example:</b> <a class="el" href="../../d2/d88/classA.html">A</a> typical (exemplary) invocation is of the form</p>
<p class="startli">~~~o2-sim -n 10 -g pythia8 -e TGeant4 -j 2 &ndash;skipModules ZDC,PHS~~~</p>
<p class="startli">which would launch a simulation for 10 pythia8 events on the whole ALICE detector but ZDC and PHOS, using Geant4 on 2 parallel worker processes.</p>
</li>
<li><b>Generated output</b>: The simulation creates the following output files:</li>
</ul>
<table class="doxtable">
<tr>
<th>File </th><th>Description  </th></tr>
<tr>
<td><code>o2sim_Kine.root</code> </td><td>contains kinematics information (primaries and secondaries) and event meta information </td></tr>
<tr>
<td><code>o2sim_geometry.root</code> </td><td>contains the final <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a> geometry created for simulation run </td></tr>
<tr>
<td><code>o2sim_grp.root</code> </td><td>special global run parameters (grp) such as field </td></tr>
<tr>
<td><code>o2sim_XXXHits.root</code> </td><td>hit file for each participating active detector XXX </td></tr>
<tr>
<td><code>o2sim_configuration.ini</code> </td><td>summary of parameter values with which the simulation was done </td></tr>
<tr>
<td><code>serverlog</code> </td><td>log file produced from the particle generator server </td></tr>
<tr>
<td><code>workerlog</code> </td><td>log file produced form the transportation processes </td></tr>
<tr>
<td><code>hitmergerlog</code> </td><td>log file produced from the IO process </td></tr>
</table>
<ul>
<li><b>Main command line options</b>: The following major options are available (incomplete):</li>
</ul>
<table class="doxtable">
<tr>
<th>Option </th><th>Description  </th></tr>
<tr>
<td>-h,&ndash;help </td><td>Prints the list of possible command line options and their default values. </td></tr>
<tr>
<td>-n,&ndash;number </td><td>The number of events to simulate. </td></tr>
<tr>
<td>-g,&ndash;generator </td><td>name of a predefined generator template to use (such as pythia8, pythia8hi). Configuration of generations is explained in a dedicated section. </td></tr>
<tr>
<td>-e,&ndash;engine </td><td>Select the VMC transport engine (TGeant4, TGeant3). </td></tr>
<tr>
<td>-m,&ndash;modules </td><td>List of modules/geometries to include (default is ALL); example -m PIPE ITS TPC </td></tr>
<tr>
<td>-j,&ndash;nworkers </td><td>Number of parallel simulation engine workers (default is half the number of hyperthread CPU cores) </td></tr>
<tr>
<td>&ndash;chunkSize </td><td>Size of a sub-event. This determines how many primary tracks will be sent to a simulation worker to process. </td></tr>
<tr>
<td>&ndash;skipModules </td><td>List of modules to skip / not to include (precedence over -m) </td></tr>
<tr>
<td>&ndash;configFile </td><td><a class="el" href="../../d2/d88/classA.html">A</a> <code>.ini</code> file containing a list of (non-default) parameters to configure the simulation run. See section on configurable parameters for more details. </td></tr>
<tr>
<td>&ndash;configKeyValues </td><td>Like <code>--configFile</code> but allowing to set parameters on the command line as a string sequence. Example <code>--configKeyValues "Stack.pruneKine=false"</code>. Takes precedence over <code>--configFile</code>. Parameters need to be known ConfigurableParams. </td></tr>
<tr>
<td>&ndash;seed </td><td>The initial seed to (all) random number instances. Default is -1 which leads to random behaviour. </td></tr>
<tr>
<td>-o,&ndash;outPrefix </td><td>How output files should be prefixed. Default is o2sim. Example <code>-o mySignalProduction</code>. </td></tr>
</table>
<ul>
<li><b>Expert control</b> via environment variables: <code>o2-sim</code> is sensitive to the following environment variables:</li>
</ul>
<table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td><b>ALICE_O2SIM_DUMPLOG</b> </td><td>When set, the output of all FairMQ components will be shown on the screen and can be piped into a user logfile. </td></tr>
<tr>
<td><b>ALICE_NOSIMSHM</b> </td><td>When set, communication between simulation processes will not happen using a shared memory mechanism but using <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a> serialization. </td></tr>
</table>
<h2>Configurable Parameters</h2>
<p>Simulation makes use of <code>configurable parameters</code> as described in the https://github.com/AliceO2Group/AliceO2/blob/dev/Common/SimConfig/doc/ConfigurableParam.md "ConfigurableParam.md" documentation. Detector code as well as general simulation code declare such parameter and access them during runtime. Once a parameter is declared, it can be influenced/set from the outside via configuration files or from the command line. See the <code>--configFile</code> as well as <code>--configKeyValues</code> command line options. The complete list of parameters and their default values can be inspected in the file <code>o2sim_configuration.ini</code> that is produced by an empty run <code>o2-sim -n 0 -m CAVE</code>.</p>
<p>Important parameters influencing the transport simulation are:</p>
<table class="doxtable">
<tr>
<th>Main parameter key </th><th>Description  </th></tr>
<tr>
<td>G4 </td><td>Parameters influencing the Geant4 engine, such as the physics list. Example "G4.physicslist=kFTFP_BERT_optical_biasing" </td></tr>
<tr>
<td>Stack </td><td>Parameters influencing the particle stack. Example include whether the stack does kinematics pruning or whether it keeps secondaries at all. </td></tr>
<tr>
<td>SimCutParams </td><td>Parameters allowing to set some sime geometry stepping cuts in R, Z, etc. </td></tr>
<tr>
<td>Diamond </td><td>Parameter allowing to set the interaction vertex location and the spread/width. Is used in all event generators. </td></tr>
<tr>
<td>Pythia6 </td><td>Parameters that influence the pythia6 generator. </td></tr>
<tr>
<td><a class="el" href="../../d3/dee/namespacePythia8.html">Pythia8</a> </td><td>Parameters that influence the pythia8 generator. </td></tr>
<tr>
<td>TriggerParticle </td><td>Parameters influencing the trigger mechanism in particle generators. </td></tr>
</table>
<p>Detectors may also have parameters influencing various pieces such geometry layout, material composition etc.</p>
<h2>Help on available generators</h2>
<p>Below some notes on example generators along with some usage info.</p>
<ul>
<li><b>Fwmugen</b></li>
</ul>
<p>fwmugen is a lightweight and simple “box” generator for forward muons (1 muon / event)</p>
<div class="fragment"><div class="line">o2-sim -m MFT -e TGeant3 -g fwmugen -n 10</div></div><!-- fragment --><ul>
<li><b>BoxGen</b></li>
</ul>
<div class="fragment"><div class="line">o2-sim -m PIPE ITS MFT -e TGeant3 -g boxgen -n 10 --configKeyValues &#39;BoxGun.pdg=13 ; BoxGun.eta[0]=-3.6 ; BoxGun.eta[1]=-2.45; BoxGun.number=100&#39;</div></div><!-- fragment --><ul>
<li><b>PYTHIA 8</b></li>
</ul>
<p>Configures pythia8 for min.bias pp collisions at 14 TeV</p>
<div class="fragment"><div class="line">o2-sim -m PIPE ITS MFT -g pythia8 -n 50</div></div><!-- fragment --><p>[Describe in detail the environment variables]</p>
<h2>Data layout</h2>
<p>[Add something on data layout of hits file]</p>
<h2>F.A.Q.</h2>
<p>You may contribute to the documentation by asking a question</p>
<h4>1. <b>How can I interface an event generator from ALIROOT</b>?</h4>
<p>In order to access event generators from ALIROOT, such as <code>THijing</code> or <code>TPyhtia6</code>, you may use the <code>-g extgen</code> command line option followed by a <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a> macro setting up the event generator. Examples thereof are available in the installation directory <code>$O2_ROOT/share/Generators/external</code>.</p>
<p>For example, in order to simulate with 10 Pythia6 events, the following command can be run: </p><div class="fragment"><div class="line">o2-sim -n 10 -g extgen --extGenFile $O2_ROOT/share/Generators/external/pythia6.C</div></div><!-- fragment --><p> Macro arguments can be passed via <code>--extGenFunc pythia6(14000., "pythia.settings")</code>.</p>
<p>Users may write there own macros in order to customize to their needs.</p>
<h4>2. <b>How can I run on a subset of geometry modules</b>?</h4>
<p>Use the <code>--modules</code> or <code>-m</code> command line option. Example: <code>o2-sim -m PIPE ITS TPC</code> will run the simulation on a geometry/material consinsting of PIPE, ITS, TPC.</p>
<h4>3. <b>How can I run with exactly the same events as used in an AliRoot simulation?</b></h4>
<p>One may perform any arbitrary simulation with AliRoot and reuse the kinematics information in form of <code>Kinemtatics.root</code> produced. The file contains primary and possibly secondary particles (added by transportation). When the file is passed to <code>o2sim</code>, the primary particles my be used as the initial event. Use the **<code>-g extkin</code>** command line option: </p><div class="fragment"><div class="line">o2-sim -g extkin --extKinFile Kinematics.root ...</div></div><!-- fragment --><h4>4. <b>How can I generate events (signal) using the vertex position of already-generated (background) events?</b></h4>
<p>This process might be called embedding, where one wants to merge two events generated independenly. For that to be physically correct, both events have to originate from the same interaction vertex. Assuming that your already-generated (background) events are stored in the <code>o2sim.background.root</code> file, you can force the interaction vertex for the generation of a new set of events to be the same as the one in the background with the following command line option:</p>
<div class="fragment"><div class="line">o2-sim --embedIntoFile o2sim.background.root</div></div><!-- fragment --><p>Background events are sampled one-by-one until all events have been used. At that point the events start to be reused.</p>
<h4>5. <b>How can I obtain detailed stepping information?</b></h4>
<p>Run the simulation (currently only supported in combination with <code>o2-sim-serial</code>) with a preloaded library: </p><div class="fragment"><div class="line">MCSTEPLOG_TTREE=1 LD_PRELOAD=$O2_ROOT/lib/libMCStepLogger.so o2-sim-serial -j 1 -n 10</div></div><!-- fragment --><p> This will produce a file <code>MCStepLoggerOutput.root</code> containing detailed information about steps and processes (where, what, ...). The file can be analysed using a special analysis framework. See <a href="https://github.com/AliceO2Group/AliceO2/blob/dev/Utilities/MCStepLogger/README.md">https://github.com/AliceO2Group/AliceO2/blob/dev/Utilities/MCStepLogger/README.md</a> for more documentation.</p>
<h4>6. <b>How can I add a trigger to the event generator?</b></h4>
<p>All event generator interfaces that comply with the <code><a class="el" href="../../d3/da7/classo2_1_1eventgen_1_1Generator.html">o2::eventgen::Generator</a></code> protocol can be triggered. <a class="el" href="../../d2/d88/classA.html">A</a> basic 'particle trigger' is implemented in the <code><a class="el" href="../../d8/d05/namespaceo2_1_1eventgen.html">o2::eventgen</a></code> core and allows the user to define a trigger particle. The definitions of the trigger particle can be expressed via command line arguments </p><div class="fragment"><div class="line">o2-sim -g pythia8 -t particle --configKeyValues &quot;TriggerParticle.pdg=333;TriggerParticle.ptMin=5.;TriggerParticle.yMin=-0.5;TriggerParticle.yMax=0.5&quot;</div></div><!-- fragment --><p>Custom triggers can also be constructed by the user to provide unlimited flexibility in the trigger needs. An external trigger function can be specified via command line arguments </p><div class="fragment"><div class="line">o2-sim -g pythia8 -t external --extTrgFile path_to_trigger_macro.C --extTrgFunc &quot;the_function(some, parameters)&quot;</div></div><!-- fragment --><p> The function must comply with a simple protocol and return a lambda function defined as follows </p><div class="fragment"><div class="line">o2::eventgen::Trigger the_function()</div><div class="line">{</div><div class="line">  return [](const std::vector&lt;TParticle&gt;&amp; particles) -&gt; bool {</div><div class="line">    return true; // triggered</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><p> Within the lambda function the user receives the stack of generated particles and can inspect it to define a trigger at will. The trigger is fired when the lambda function returns <code>true</code> and the simulation of the current event is subsequently started.</p>
<p>To allow users to define triggers that go beyond the particle stack generated by the event generator, another functionality is added. This allows the user to go deep into the core of the event generator, whenever this is possible. For this reason, this is called a 'DeepTrigger'. <a class="el" href="../../d2/d88/classA.html">A</a> 'DeepTrigger' is attached to the simulation in the same way as a normal trigger </p><div class="fragment"><div class="line">o2-sim -g pythia8 -t external --extTrgFile path_to_deep_trigger_macro.C --extTrgFunc &quot;the_deep_function(some, parameters)&quot;</div></div><!-- fragment --><p> In this case the function must comply with a similar, but different protocol than before and return a lambda function defined as follows </p><div class="fragment"><div class="line">{</div><div class="line">  return [mpiMin](void* interface, std::string name) -&gt; bool {</div><div class="line">    return true;</div><div class="line">  };</div><div class="line">}</div></div><!-- fragment --><p> Notice that in this case the user is presented with a pointer to the event-generator interface and a string that defines its name. For the sake of generality, a <code>void*</code> has to be used in order to pass any possible types of event-generators, that are normally othogonal one to another. The name encodes a string to identify what generator has been passed and perform the correct cast to use it.</p>
<h3>Deep triggers</h3>
<p>Deep triggers is just a name to a new functionality that allows the user to define custom functions that will have a direct handle on the event generator interface. The functionality follows the schema of the previous point, with the user providing a custom lambda function that will receive from the framework a pointer to the internal event-generator interface object (i.e. for <a class="el" href="../../d3/dee/namespacePythia8.html">Pythia8</a>, a pointer to the Pythia object) and a tagname to identify the interface. This functionality might be useful to users who want to provide triggers based on information beyond the stack of the generated particles, based on more internal counters/information in the event generator machinery.</p>
<p>Here is an example of a deep trigger implementation in <a class="el" href="../../d3/dee/namespacePythia8.html">Pythia8</a>.</p>
<div class="fragment"><div class="line">//   usage: o2sim --trigger external --extTrgFile trigger_mpi.C</div><div class="line">// options:                          --extTrgFunc &quot;trigger_mpi()&quot;</div><div class="line"></div><div class="line">#include &quot;Generators/Trigger.h&quot;</div><div class="line">#include &quot;Pythia8/Pythia.h&quot;</div><div class="line"></div><div class="line">o2::eventgen::DeepTrigger</div><div class="line">  trigger_mpi(int mpiMin = 5)</div><div class="line">{</div><div class="line">  return [mpiMin](void* interface, std::string name) -&gt; bool {</div><div class="line">    if (!name.compare(&quot;pythia8&quot;)) {</div><div class="line">      auto py8 = reinterpret_cast&lt;Pythia8::Pythia*&gt;(interface);</div><div class="line">      return py8-&gt;info.nMPI() &gt;= mpiMin;</div><div class="line">    }</div><div class="line">    LOG(FATAL) &lt;&lt; &quot;Cannot define MPI for generator interface \&#39;&quot; &lt;&lt; name &lt;&lt; &quot;\&#39;&quot;;</div><div class="line">    return false;</div><div class="line">  };</div><div class="line">}</div></div><!-- fragment --><h3><a class="el" href="../../d3/dee/namespacePythia8.html">Pythia8</a> UserHooks</h3>
<p><a class="el" href="../../d3/dee/namespacePythia8.html">Pythia8</a> machinery allows the user to hook some code at various stages of the event-generation process. For details, please look at Pyhia8 manual. <a href="http://home.thep.lu.se/~torbjorn/pythia82html/UserHooks.html">http://home.thep.lu.se/~torbjorn/pythia82html/UserHooks.html</a></p>
<p>The interface is provided via a configuration macro, where the user will have to define a custom UserHooks according to the protocol defined by <a class="el" href="../../d3/dee/namespacePythia8.html">Pythia8</a>. The macro will also have to provide a function to retrieve the pointer to the created custom UserHooks object.</p>
<p>This functionality might be of use for users who want to be able to steer the event-generation process from very deep inside the internal routines and want to veto some specific processes based on analysis of the status of <a class="el" href="../../d3/dee/namespacePythia8.html">Pythia8</a> at the various stages, i.e. veto events that do not have charm partons, before hadronisation of partons. This can save time in the event generation process as many steps can be skipped already at early time.</p>
<p>An example of a configuration macro is this one</p>
<div class="fragment"><div class="line">//   usage: o2sim -g pythia8 --configKeyValue &quot;Pythia8.hooksFileName=pythia8_userhooks_charm.C&quot;</div><div class="line"></div><div class="line">#include &quot;Generators/Trigger.h&quot;</div><div class="line">#include &quot;Pythia8/Pythia.h&quot;</div><div class="line"></div><div class="line">class UserHooksCharm : public Pythia8::UserHooks</div><div class="line">{</div><div class="line"> public:</div><div class="line">  UserHooksCharm() = default;</div><div class="line">  ~UserHooksCharm() = default;</div><div class="line">  bool canVetoPartonLevel() override { return true; };</div><div class="line">  bool doVetoPartonLevel(const Pythia8::Event&amp; event) override</div><div class="line">  {</div><div class="line">    for (int ipa = 0; ipa &lt; event.size(); ++ipa) {</div><div class="line">      if (abs(event[ipa].id()) != 4)</div><div class="line">        continue;</div><div class="line">      if (fabs(event[ipa].y()) &gt; 1.5)</div><div class="line">        continue;</div><div class="line">      return false;</div><div class="line">    }</div><div class="line">    return true;</div><div class="line">  };</div><div class="line">};</div><div class="line"></div><div class="line">Pythia8::UserHooks*</div><div class="line">  pythia8_userhooks_charm()</div><div class="line">{</div><div class="line">  return new UserHooksCharm();</div></div><!-- fragment --><h3>Pythia6 interface</h3>
<p><a class="el" href="../../d2/d88/classA.html">A</a> new Pythia6 interface is provided via GeneratorPythia6. This complies with the <a class="el" href="../../d3/da7/classo2_1_1eventgen_1_1Generator.html">o2::eventgen::Generator</a> protocol, and hence the user is allowed to use all the trigger functionalities. The class can also be used for DeepTriggers as this modified macro shows.</p>
<div class="fragment"><div class="line">//   usage: o2sim --trigger external --extTrgFile trigger_mpi.C</div><div class="line">// options:                          --extTrgFunc &quot;trigger_mpi()&quot;</div><div class="line"></div><div class="line">#include &quot;Generators/Trigger.h&quot;</div><div class="line">#include &quot;Pythia8/Pythia.h&quot;</div><div class="line">#include &quot;TPythia6.h&quot;</div><div class="line"></div><div class="line">o2::eventgen::DeepTrigger</div><div class="line">  trigger_mpi(int mpiMin = 15)</div><div class="line">{</div><div class="line">  return [mpiMin](void* interface, std::string name) -&gt; bool {</div><div class="line">    int nMPI = 0;</div><div class="line">    if (!name.compare(&quot;pythia8&quot;)) {</div><div class="line">      auto py8 = reinterpret_cast&lt;Pythia8::Pythia*&gt;(interface);</div><div class="line">      nMPI = py8-&gt;info.nMPI();</div><div class="line">    }</div><div class="line">    else if (!name.compare(&quot;pythia6&quot;)) {</div><div class="line">      auto py6 = reinterpret_cast&lt;TPythia6*&gt;(interface);</div><div class="line">      nMPI = py6-&gt;GetMSTI(31);</div><div class="line">    }</div><div class="line">    else</div><div class="line">      LOG(FATAL) &lt;&lt; &quot;Cannot define MPI for generator interface \&#39;&quot; &lt;&lt; name &lt;&lt; &quot;\&#39;&quot;;</div><div class="line">    return nMPI &gt;= mpiMin;</div><div class="line">  };</div><div class="line">}</div></div><!-- fragment --><h2>Development</h2>
<h1>Documentation of the digitization step <a class="anchor" id="DigitSection"></a></h1>
<p>Digitization - the transformation of hits produced in the transport simulation to electronics detector output - is steered by the <code>o2-sim-digitizer-workflow</code> executable. The executable is implemented as a https://github.com/AliceO2Group/AliceO2/blob/dev/Framework/Core/README.md "DPL workflow". The main components in this workflow are:</p><ul>
<li><b><a class="el" href="../../d2/d88/classA.html">A</a> SimReader</b> process, responsible to analyze available simulation information/kinematics and to setup the digitization context, which describes things such as the structure of the timeframe (bunch cross properties and interaction rate) as well as how to combine different background and signal hits.</li>
<li><b>Digitizer processors</b> per detector, responsible for the actual digitization upon receiving the digitization context from the SimReader.</li>
<li><b>IO processors</b> per detector, responsible to write digits to files.</li>
<li><b>GRP updater</b>, a process to update the GRP file with information aquired in digitization.</li>
</ul>
<h2>Usage overview:</h2>
<ul>
<li><p class="startli"><b>Quick start example:</b> <a class="el" href="../../d2/d88/classA.html">A</a> minimal invocation is of the form</p>
<p class="startli">~~~o2-sim-digitizer-workflow [&ndash;sims foo] -b~~~</p>
<p class="startli">which would launch the digitization phase for all detectors that took part in a simulation stored under simulation prefix <code>foo</code> (default o2sim) and will digitize all events with a default bunch crossing structure. All digitizer will run in parallel to each other.</p>
</li>
<li><p class="startli"><b><a class="el" href="../../d2/d88/classA.html">A</a> more advanced example:</b></p>
<p class="startli">~~~o2-sim-digitizer-workflow &ndash;sims bkg,sgn &ndash;interactionRate 1e6 &ndash;onlyDet TPC,ITS -b~~~</p>
<p class="startli">which would launch the digitization phase for TPC and ITS with a custom LHC interactionRate. Moreover, this example does summation of digits coming from background (prefix bkg) as well as signal (prefix sgn) transport simulations.</p>
</li>
<li><b>Generated output</b>: The digitization process creates the following output files:</li>
</ul>
<table class="doxtable">
<tr>
<th>File </th><th>Description  </th></tr>
<tr>
<td><code>collisioncontext.root</code> </td><td>Contains information about the collision/digitization context used in this digitization. Keeps the list of input files and how collisions were composed for the digits embedding process and time stamps where assigned. </td></tr>
<tr>
<td><code>XXXdigits.root</code> </td><td>Typically one digit file per detector XXX in a timeframe format. The file also typically contains mappings of digit indices to MC labels. </td></tr>
<tr>
<td><code>o2simdigitizerworkflow_configuration.ini</code> </td><td><a class="el" href="../../d1/d4a/structSummary.html">Summary</a> of parameters used in the digitization process. </td></tr>
</table>
<ul>
<li><b>Main command line options</b>: The following major options are available:</li>
</ul>
<table class="doxtable">
<tr>
<th>Option </th><th>Description  </th></tr>
<tr>
<td>-h,&ndash;help </td><td>Prints the list of possible command line options and their default values. </td></tr>
<tr>
<td>&ndash;sims </td><td>Comma separated list of simulation prefixes that should be overlaid/embedded. Example <code>--sims background,signal</code> where <code>background</code> and <code>signal</code> refer to transport simulation productions. Final collisions will be composed from both of them (in a round robin fashion). See separate section about <a href="../../#Embedding">Embedding</a> for more details. If just one prefix is given, normal digitization without overlay will be done. </td></tr>
</table>
<p>| &ndash;tpc-lanes | Number of parallel digitizers for TPC, which has a special attention due an increased data rate compared to other detectors. | | | &ndash;interactionRate | Total hadronic interaction rate (Hz). | | &ndash;bcPatternFile | Interacting BC pattern file chaning the default bunch crossing pattern. | | &ndash;onlyDet | Comma separated list of detectors to digitize. (Default is all) | | &ndash;skipDet | Comma separed list of detectors to exclude. | | &ndash;incontext | Name of context file. Useful for reusing a context from a previous run when we split the processing detectorwise. | | &ndash;outcontext | Specify name of contextfile to produce. | | &ndash;simFileQED | Optional special QED hit file to include effect from QED effects into digitization. |</p>
<h2>Embedding <a class="anchor" id="Embedding"></a></h2>
<h2>Monte Carlo Labels <a class="anchor" id="MCLabels"></a></h2>
<p>We can associate digits to tracks/particles of the original transport simulation, so as to keep provenance information of how digits were triggered. This information can be passed forward to reconstruction and analysis and used to study reconstruction efficiencies etc.</p>
<p>To this end, a special data object <code>MCCompLabel</code> is offered, which allows to encapsulate the identifiers of track, event and source kinematics files. </p><div class="fragment"><div class="line">MCCompLabel(<span class="keywordtype">int</span> trackID, <span class="keywordtype">int</span> evID, <span class="keywordtype">int</span> srcID, <span class="keywordtype">bool</span> fake = <span class="keyword">false</span>)</div></div><!-- fragment --><p> This information should be enough to lookup and load the precise Monte Carlo track (<a href="../../#MCReader">see here</a>).</p>
<p>Association of digits to an arbitrary number of labels is done via filling a <b>separate</b> and <b>dedicated</b> container called <code>MCTruthContainer</code> which is written as a separate branch to the output file, next to the branch for digits. This has the advantage that digits may be kept as close as possible to the raw data and we can have arbitrary number of labels at a minimal memory cost.</p>
<p>The mechanics is as follows: For a collection of digits created for detector <code>foo</code> </p><div class="fragment"><div class="line">std::vector&lt;o2::foo::Digits&gt; mDigits;</div></div><!-- fragment --><p> we keep a separate container of labels of type: </p><div class="fragment"><div class="line"><a class="code" href="../../dc/daa/classo2_1_1dataformats_1_1MCTruthContainer.html">o2::dataformats::MCTruthContainer&lt;o2::dataformats::MCCompLabel&gt;</a> mLabelContainer;</div></div><!-- fragment --><p> Querying the labels works by positional correspondance: Labels for the digit at position <code>pos</code> can be accessed in the following way: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; digit = mDigits[pos];</div><div class="line"><span class="comment">// returns an iterable view of labels</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; labels_for_digit = mLabelContainer.<a class="code" href="../../dc/daa/classo2_1_1dataformats_1_1MCTruthContainer.html#a47e20a65d29e6613e3deeedad9d7990f">getLabels</a>(pos);</div><div class="line"><span class="comment">// iterate over labels</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="../../dc/da3/glcorearb_8h.html#a9371a1f53f8067997cd15aaf657c62d0">label</a> : labels_for_digit) {</div><div class="line">   <span class="comment">// process label</span></div><div class="line">}</div></div><!-- fragment --><p>If positional correspondance is too weak, one may eventualy choose to record the corresponding data index in the labelcontainer inside the digit itself: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; digit = mDigits[pos];</div><div class="line"><span class="comment">// returns an iterable view of labels</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span>&amp; labels_for_digit = mLabelContainer.<a class="code" href="../../dc/daa/classo2_1_1dataformats_1_1MCTruthContainer.html#a47e20a65d29e6613e3deeedad9d7990f">getLabels</a>(digit.labelindex);</div><div class="line"><span class="comment">// iterate over labels</span></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="../../dc/da3/glcorearb_8h.html#a9371a1f53f8067997cd15aaf657c62d0">label</a> : labels_for_digit) {</div><div class="line">   <span class="comment">// process label</span></div><div class="line">}</div></div><!-- fragment --><h2>Accessing Monte Carlo kinematics after the digitization phase <a class="anchor" id="MCReader"></a></h2>
<p>After digitization is done, one can use the <code>MCKinematicsReader</code> class to load and access the Monte Carlo tracks. The MCKinematicsReader needs the digitization context file, generated during digitization. Once initialized it can return the tracks associated to a Monte Carlo label.</p>
<p><a class="el" href="../../d2/d88/classA.html">A</a> typical code example may be </p><div class="fragment"><div class="line"><span class="comment">// init the reader from the context</span></div><div class="line"><a class="code" href="../../db/dde/classo2_1_1steer_1_1MCKinematicsReader.html">o2::steer::MCKinematicsReader</a> reader(<span class="stringliteral">&quot;collisioncontext.root&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// load digits from the digits file --&gt; save in alldigits</span></div><div class="line"><span class="comment">// load the label container from the digits file --&gt; save in labelcontainer</span></div><div class="line"></div><div class="line"><span class="comment">// this is simply iterating over all the digits and querying the tracks that contributed to these digits</span></div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> pos = 0; pos &lt; alldigits.size(); ++pos) {</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; digit = alldigits[pos];</div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span>&amp; labels_for_digit = labelcontainer.getLabels(pos);</div><div class="line">  <span class="comment">// iterate over labels</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; <a class="code" href="../../dc/da3/glcorearb_8h.html#a9371a1f53f8067997cd15aaf657c62d0">label</a> : labels_for_digit) {</div><div class="line">     track = reader.getTrack(<a class="code" href="../../dc/da3/glcorearb_8h.html#a9371a1f53f8067997cd15aaf657c62d0">label</a>);</div><div class="line">     <span class="comment">// do something with the track</span></div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h1>Simulation tutorials/examples <a class="anchor" id="Examples"></a></h1>
<p>Some examples for the usage of simulation and digitization are collected in an <a href="../../../run/SimExamples">examples folder</a>. Other helpful resources are the scripts used for regression testing in <a href="../../../prodtests">prodtests</a>.</p>
<table class="doxtable">
<tr>
<th>Example </th><th>Short Description  </th></tr>
<tr>
<td><a href="../../../run/SimExamples/AliRoot_Hijing">AliRoot_Hijing</a> </td><td>Example showing how to use Hijing from AliRoot for event generation </td></tr>
<tr>
<td><a href="../../../run/SimExamples/Adaptive_Pythia8">Adaptive_Pythia8</a> </td><td>Complex example showing <b>generator configuration for embedding</b> that cat adapt the response based on the background event </td></tr>
<tr>
<td><a href="../../../run/SimExamples/Signal_ImpactB">Signal_ImpactB</a> </td><td>Example showing <b>generator configuration for embedding</b> that cat adapt to the impact parameter of the background event </td></tr>
<tr>
<td><a href="../../../run/SimExamples/HepMC_STARlight">HepMC_STARlight</a> </td><td>Simple example showing <b>generator configuration</b> that runs a standalone <code>STARlight</code> generation that couples to the <code><a class="el" href="../../d4/d7c/namespaceo2.html" title="information complementary to a CCDB object (path, metadata, startTimeValidity, endTimeValidity etc) ...">o2</a></code> via a <code><a class="el" href="../../d1/d98/namespaceHepMC.html">HepMC</a></code> file </td></tr>
<tr>
<td><a href="../../../run/SimExamples/Jet_Embedding_Pythia8">Jet_Embedding_Pythia</a> </td><td>Complex example showing <b>generator configuration</b>, <b>digitization embedding</b>, <b>MCTrack access</b> </td></tr>
<tr>
<td><a href="../../../prodtests/sim_challenge.sh">sim_challenge.sh</a> </td><td>Basic example doing a <b>simple transport, digitization, reconstruction pipeline</b> on the full dectector. All stages use parallelism. </td></tr>
<tr>
<td><a href="../../../prodtests/sim_performance_test.sh">sim_performance.sh</a> </td><td>Basic example for serial transport and linearized digitization sequence (one detector after the other). Serves as standard performance candle. </td></tr>
</table>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d7/d16/refdoc.html">Documentation pages</a></li>
    <li class="footer">Generated on Thu Jun 4 2020 09:30:40 for Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
