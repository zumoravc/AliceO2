<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: Core</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d4/d0b/refFrameworkCore.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Core </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="../../db/dd3/refFrameworkCoreCOOKBOOK.html">Core COOKBOOK</a> Core COOKBOOK <a class="el" href="../../de/d8c/refFrameworkCoreANALYSIS.html">Core ANALYSIS</a> Core ANALYSIS</p>
<h1>Data Processing Layer in O2 Framework</h1>
<h2>Status quo and motivation for an O2 Data Processing Layer</h2>
<p>FairMQ currently provides a well documented and flexible framework for an actor based computation where each of the actors listens for message-like entities on channels and executes some code as a reaction. The key component which controls this is called a <code><a class="el" href="../../db/dfe/classFairMQDevice.html">FairMQDevice</a></code> (or <em>device</em> from now on) which can use different kind of transports to receive and send messages. In the most generic case, users are allowed to have full control on the state machine governing the message passing and have complete control on how the message handling is done. This of course covers all ALICE usecases in a generic manner, at the cost of extra complexity left to the user to implement. In most cases however a simplified way of creating devices is provided, and the user will simply create its own <code><a class="el" href="../../db/dfe/classFairMQDevice.html">FairMQDevice</a></code>-derived class, which registers via the <code>OnData(FairMQParts &amp;parts)</code> method a callback that is invoked whenever a new message arrives. This however still holds the user responsible for:</p>
<ul>
<li>Verifying that the required inputs for the computation are all available, both from the actual data flow (being it for readout, reconstruction or analysis) and from the asynchronous stream (e.g. alignment and calibrations).</li>
<li>Create the appropriate message which holds the results and send it.</li>
<li>Ensure the ease of testability, the code reuse and the proper documentation <code>OnData</code> callback. In particular there is no way to inspect which data is expected by a device and which data is produced.</li>
</ul>
<p>This is by design, because the FairMQ transport layer should not know anything about the actual data being transferred, while all the points above require some sort of inner knowledge about the data model and the data being moved around.</p>
<p>The aim is to achieve the following:</p>
<ul>
<li><b>Explicit data flow:</b> Input and outputs are declared upfront and can be used for documentation or for automatic topology creation (assuming the actual processing environment is known).</li>
<li><b>Transport agnostic data processing:</b> users will not have to know about the details of how the data materialises on their device, they will always be handed the full set of payloads they requested, even if they come at different time.</li>
<li><b>Composability of data processing:</b> different process functions can in principle be chained and scheduled together depending on the desired granularity for devices.</li>
</ul>
<h2>Separating data-processing from transport</h2>
<p>For the reasons mentioned above, we propose that the one of the developments which should happen with the O2 Framework work package is the development of a “Data Processing layer” which actually knows about the O2 Data <a class="el" href="../../d6/d18/classModel.html">Model</a> (and for this reason cannot be part of FairMQ itself) and exploits it to validate, optimise and correctly schedule a computation on a user specified set of inputs.</p>
<p>The Data Processing Layer in particular requires:</p>
<ul>
<li>That the inputs types of each computation are provided upfront.</li>
<li>That the outputs types of each computation are provided upfront.</li>
<li>That a time identifier can be associated to inputs</li>
</ul>
<p>and given these premises it actually guarantees:</p>
<ul>
<li>That whenever a new input arrives a <code>CompletionPolicy</code> is executed to decide wether the associate record is complete. By default such a <code>CompletionPolicy</code> waits for all the specified parts to have arrived.</li>
<li>That no message passing happens during the performing of the computation, but uniquely at the end.</li>
</ul>
<h3>Instanciating a workflow</h3>
<p>The description of the computation in such the Data Processing Layer is done via instances of the <code>DataProcessorSpec</code> class, grouped in a so called <code>WorkflowSpec</code> instance. In order to provide a description a computation to be run, the user must implement a callback which return an filled <code>WorkflowSpec</code>. E.g.:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Framework/Utils/runDataProcessing.h&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#a7daf5fb16896e1e754a18cfcf37e665b">WorkflowSpec</a> <a class="code" href="../../d5/d75/centralityQa_8cxx.html#af7d4c4ac874e3b6bf3dcb688a4c64b1b">defineDataProcessing</a>(ConfigContext &amp;context) {</div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#a7daf5fb16896e1e754a18cfcf37e665b">WorkflowSpec</a> {</div><div class="line">    DataProcessorSpec{</div><div class="line">      ...</div><div class="line">    },</div><div class="line">    DataProcessorSpec{</div><div class="line">      ...</div><div class="line">    }</div><div class="line">  };</div><div class="line">};</div></div><!-- fragment --><p>See next section, for a more detailed description of the <code>DataProcessorSpec</code> class. The code above has to be linked into a single executable together with the Data Processing Layer code to form a so called driver executable which if run will:</p>
<ul>
<li>Map all <code>DataProcessorSpec</code> to a set of <code><a class="el" href="../../db/dfe/classFairMQDevice.html">FairMQDevice</a></code>s (using 1-1 correspondence, in the current implementation).</li>
<li>Instanciate and start all the devices resulted from the previous step.</li>
<li>(Optionally) start a GUI which allows to monitor the running of the system.</li>
</ul>
<p>The <code>ConfigContext</code> object being passed to the function contains a set of user provided options to customise the creation of the workflow. For example you might want to change the number of workers for a given task or disable part of the topology if a given detector should not be enabled.</p>
<p>In order to specify which options are to be present in the <code>ConfigContext</code>, the user can define the extension point:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/d90/trackselection_8cxx.html#a1847186994155009dc39999a652c9b3d">customize</a>(std::vector&lt;o2::framework::ConfigParamSpec&gt; &amp;workflowOptions)</div></div><!-- fragment --><h3>Describing a computation</h3>
<p>The description of the computation in such a layer is done via a <code>DataProcessorSpec</code> class, which describes some sort of processing of a (set of) O2 Data Payloads (<em>payloads</em> from now on), as defined by the O2 Data <a class="el" href="../../d6/d18/classModel.html">Model</a>, eventually producing new payloads as outputs. The inputs to the computation, the outputs and the actual code to run on the former to produce the latter, is specified in a <code>DataProcessorSpec</code> instance. Multiple <code>DataProcessorSpec</code> instances can be grouped together in a <code>WorkflowSpec</code>to the driver code which maps them to processing devices accordingly.</p>
<p>The <code>DataProcessorSpec</code> is defined as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DataProcessorSpec {</div><div class="line">   <span class="keyword">using</span> InitCallback = std::function&lt;ProcessCallback(InitContext &amp;)&gt;;</div><div class="line">   <span class="keyword">using</span> ProcessCallback = std::function&lt;void(ProcessingContext &amp;)&gt;;</div><div class="line">   <span class="keyword">using</span> ErrorCallback = std::function&lt;void(ErrorContext &amp;)&gt;;</div><div class="line">   std::vector&lt;InputSpec&gt; inputs;</div><div class="line">   std::vector&lt;OutputSpec&gt; outputs;</div><div class="line">   std::vector&lt;ConfigParamSpec&gt; configParams;</div><div class="line">   std::vector&lt;std::string&gt; requiredServices;</div><div class="line">   AlgorithmSpec algorithm;</div><div class="line">};</div></div><!-- fragment --><p>the inputs field represents a set of subscriptions to some kind of input data we would like to process. As per O2 Data <a class="el" href="../../d6/d18/classModel.html">Model</a> there is 3 major properties O2 attaches to a message: its origin, a description and a generic subspecification.</p>
<p>So: </p><pre class="fragment">{InputSpec{"clusters", "TPC", "CLUSTERS", 0}}
</pre><p>really means "subscribe in input to the messages which have origin "TPC", contain objects of kind "CLUSTERS" and have a generic 
subspecification 0 (e.g. to index the sector). In your code you will be able to retrieve these kind of messages using the "clusters" label (see later the description of the InputRecord API).An InputSpec is effectively a three dimensional selection on space defined by all the possible origins, descriptions and subspecifications.</p>
<p>Notice that the method <code><a class="el" href="../../dd/d8d/namespaceo2_1_1framework.html#ad664c1ff709d31a98e8738b75af196bd">o2::framework::select</a></code> can be used to provide the query in a more compact (and flexible way). Using such an helper the above becomes: </p><pre class="fragment"> select("clusters:TPC/CLUSTERS/0")
</pre><p>Similarly the <code>OutputSpec</code> is a description of what the DataProcessor will produce, again in terms of (origin, description, subspecification) properties.</p>
<p>The <code>configParams</code> vector would be used to specify which configuration options the data processing being described requires:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ConfigParamSpec {</div><div class="line">  std::string <a class="code" href="../../dc/da3/glcorearb_8h.html#a5c4947d4516dd7cfa3505ce3a648a4ef">name</a>;</div><div class="line">  <span class="keyword">enum</span> ParamType <a class="code" href="../../dc/da3/glcorearb_8h.html#a7d05960f4f1c1b11f3177dc963a45d86">type</a>;</div><div class="line">  <a class="code" href="../../d4/d54/GPUReconstructionKernels_8h.html#ae43d836cf57a6bcfb9be3da4978b61d4">variant</a> defaultValue;</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>command line / configuration options would be automatically generated by it. These are available only at init stage, and can be used to configure services. They are not available to the actual <code>process</code> callback as all the critical parameters for data processing should be part of the data stream itself, eventually coming from CCDB / ParameterManager.</p>
<p>Similarly the <code>requiredServices</code> vector would define which services are required for the data processing. For example this could be used to declare the need for some data cache, a GPU context, a thread pool.</p>
<p>The <code>algorithm</code> property, of <code>AlgorithmSpec</code> is instead used to specify the actual computation. Notice that the same <code>DataProcessorSpec</code> can use different <code>AlgorithmSpec</code>. The rationale for this is that while inputs and outputs might be the same, you might want to compare different versions of your algorithm. The <code>AlgorithmSpec</code> resembles the following:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>AlgorithmSpec {</div><div class="line">  <span class="keyword">using</span> ProcessCallback = std::function&lt;void(ProcessingContext &amp;)&gt;;</div><div class="line">  <span class="keyword">using</span> InitCallback = std::function&lt;ProcessCallback(InitContext &amp;)&gt;;</div><div class="line">  <span class="keyword">using</span> ErrorCallback = std::function&lt;void(ErrorContext &amp;)&gt;;</div><div class="line"></div><div class="line">  InitCallback onInit = <span class="keyword">nullptr</span>;</div><div class="line">  ProcessCallback onProcess = <span class="keyword">nullptr</span>;</div><div class="line">  ErrorCallback onError = <span class="keyword">nullptr</span>;</div><div class="line">  ...</div><div class="line">};</div></div><!-- fragment --><p>The <code>onProcess</code> function is to be used for stateless computations. It’s a free function and it’s up to the framework to make sure that all the required components are declared upfront. It takes as input the context for the current computation in the form of a <code>ProcessingContext &amp;</code> instance. Such a context consist of:</p>
<ul>
<li>An <code>InputRecord</code> which allows retrieving the current inputs matching the provided specification.</li>
<li><a class="el" href="../../d2/d88/classA.html">A</a> <code>ServiceRegistry</code> referencing the set of services it declared as required the computation.</li>
<li><a class="el" href="../../d2/d88/classA.html">A</a> <code>DataAllocator</code> allocator which can allocate new payloads only for the types which have been declared as <code>outputs</code>.</li>
</ul>
<h4>Stateful processing</h4>
<p><code>onProcess</code> is useful whenever your computation is fully contained in your input. In several cases, however, a computation requires some ancillary state, which needs to be initialised only on (re-)start of the job. For example you might want to initialise the geometry of your detector or open a file for reading. To do so, you can use the <code>onInit</code> callback, create the state in it and pass it to the returned <code>ProcessCallback</code> as captured arguments.</p>
<p>E.g:</p>
<div class="fragment"><div class="line">AlgorithmSpec{</div><div class="line">  InitCallBack{[](InitContext &amp;setup){</div><div class="line">      <span class="keyword">auto</span> statefulGeo = std::make_shared&lt;TGeo&gt;();</div><div class="line">      <span class="keywordflow">return</span> [geo = statefulGeo](ProcessingContext &amp;) {</div><div class="line">        <span class="comment">// do something with geo</span></div><div class="line">      };</div><div class="line">    }</div><div class="line">  }</div><div class="line">}</div></div><!-- fragment --><h3>Task based API</h3>
<p>The previous API is flexible enough to work for large variety of cases, including creating <code>onProcess</code> callback on the fly depending on the <code>onInit</code> parameters. However, very often what the user wants to do is to initialise some state and and invoke a "run" method. For this we provide a <code>Task</code> based API. In order to do so, you need to inherit your task from <code><a class="el" href="../../de/dac/classo2_1_1framework_1_1Task.html">o2::framework::Task</a></code> and use the adaptor:</p>
<div class="fragment"><div class="line">adaptFromTask&lt;TASK&gt;(task constructor arguments) -&gt; AlgorithmSpec</div></div><!-- fragment --><p>to create the <code>AlgorithmSpec</code>. <a class="el" href="../../d2/d88/classA.html">A</a> full example can be found in <code>Framework/Core/test/test_Task.cpp</code></p>
<h2>Implementing a computation</h2>
<p>This chapter describes how to actually implement an <code>AlgorithmSpec</code>.</p>
<h3>Using inputs - the <code>InputRecord</code> API</h3>
<p>Inputs to your computation will be provided to you via the <code>InputRecord</code>. An instance of such a class is hanging from the <code>ProcessingContext</code> your computation lambda is passed and contains one value for each of the <code>InputSpec</code> you specified. E.g.:</p>
<div class="fragment"><div class="line">InputRecord &amp;inputs = ctx.inputs();</div></div><!-- fragment --><p>From the <code>InputRecord</code> instance you can get the arguments either via their positional index:</p>
<div class="fragment"><div class="line">DataRef <a class="code" href="../../dc/da3/glcorearb_8h.html#ad32bdec748ba376f6c0d2df39ab9a95b">ref</a> = inputs.getByPos(0);</div></div><!-- fragment --><p>or using the mnemonics-label which was used as first argument in the associated <code>InputSpec</code>.</p>
<div class="fragment"><div class="line">DataRef ref = inputs.get(<span class="stringliteral">&quot;points&quot;</span>);</div></div><!-- fragment --><p>You can then use the <code>DataRef</code> <code>header</code> and <code>payload</code> raw pointers to access the data in the messages.</p>
<p>If the message is of a known messageable type, you can automatically get the content of the message by passing type <a class="el" href="../../d1/def/classT.html">T</a> as template argument. The actual operation depends on the properties of the type. Not all types are supported, in order to get an object with pointer-like behavior, <a class="el" href="../../d1/def/classT.html">T</a> has to be a pointer (<a class="el" href="../../d1/def/classT.html">T</a> = U*).</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> p = args.get&lt;T&gt;(<span class="stringliteral">&quot;input&quot;</span>);</div></div><!-- fragment --><p> The return type is</p>
<ul>
<li><code><a class="el" href="../../d1/def/classT.html">T</a> const&amp;</code> if <code><a class="el" href="../../d1/def/classT.html">T</a></code> is a messageable type</li>
<li><code><a class="el" href="../../d1/def/classT.html">T</a></code> if <code><a class="el" href="../../d1/def/classT.html">T</a></code> is a <code>std::container</code> of a ROOT-serializable type</li>
<li><code>smart_pointer&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code> if <code><a class="el" href="../../d1/def/classT.html">T</a></code> is a ROOT-serializable type and <code>T*</code> is passed</li>
</ul>
<p>Examples:</p>
<ul>
<li>for messageable types there is no additional copy involved, the content is only for reading.</li>
</ul>
<div class="fragment"><div class="line"><a class="code" href="../../d3/d90/structXYZ.html">XYZ</a> <span class="keyword">const</span>&amp; p = args.get&lt;<a class="code" href="../../d3/d90/structXYZ.html">XYZ</a>&gt;(<span class="stringliteral">&quot;points&quot;</span>);</div></div><!-- fragment --><ul>
<li>ROOT-serialized objects are automatically deserialized and returned as a smart pointer. Note that the requested type has to be pointer.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> <a class="code" href="../../dc/da3/glcorearb_8h.html#afa0fb1b5e976920c0abeff2dca3ed774">h</a> = args.get&lt;TH1*&gt;(<span class="stringliteral">&quot;histo&quot;</span>);</div><div class="line"><a class="code" href="../../dc/da3/glcorearb_8h.html#afa0fb1b5e976920c0abeff2dca3ed774">h</a>-&gt;Print();</div></div><!-- fragment --><ul>
<li>container of ROOT-serialized objects are automatically deserialized and returned as container object.</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">auto</span> points = args.get&lt;std::vector&lt;TPoint&gt;&gt;(<span class="stringliteral">&quot;points&quot;</span>);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span>&amp; point : points) {}</div></div><!-- fragment --><p>Check next section for known types. The framework will also take care of necessary deserialization.</p>
<h3>Creating outputs - the DataAllocator API</h3>
<p>In order to prevent algorithms to create data they are not supposed to create, a special <code>DataAllocator</code> object is passed to the process callback, so that only messages for declared outputs can be created. <a class="el" href="../../d2/d88/classA.html">A</a> <code>DataAllocator</code> can create Framework owned resources via the <code>make&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code> method. In case you ask the framework to create a collection of objects, the result will be a <code>gsl::span</code> wrapper around the collection. <a class="el" href="../../d2/d88/classA.html">A</a> <code>DataAllocator</code> can adopt externally created resources via the <code>adopt</code> method. <a class="el" href="../../d2/d88/classA.html">A</a> <code>DataAllocator</code> can create a copy of an externally owned resource via the <code>snapshot</code> method.</p>
<p>Currently supported data types for <code>make&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;</code> are:</p>
<ul>
<li>Vanilla <code>char *</code> buffers with associated size: this is the actual contents of the FairMQ message.</li>
<li>Messageable types: trivially copyable, non-polymorphic types. These get directly mapped on the message exchanged by FairMQ and are therefore "zerocopy" for what the Data Processing Layer is concerned.</li>
<li>Collections of messageable types, exposed to the user as <code>gsl::span</code>.</li>
<li><a class="el" href="../../d5/d0f/classTObject.html">TObject</a> derived classes. These are actually serialised via a <a class="el" href="../../d9/dc7/classTMessage.html">TMessage</a> and therefore are only suitable for the cases in which the cost of such a serialization is not an issue.</li>
</ul>
<p>Currently supported data types for <code>snapshot</code> functionality, state at time of calling <code>snapshot</code> is captured in a copy, and sent when processing is done:</p>
<ul>
<li>Messageable types.</li>
<li>ROOT-serializable classes, serialised via a <code><a class="el" href="../../d9/dc7/classTMessage.html">TMessage</a></code>. Classes implementing <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a>'s <code>TClass</code> interface and std containers of those are automatically detected. ROOT-serialization can be forced using type converter <code>ROOTSerialized</code>, e.g. for types which can not be detected automatically</li>
<li><code>std::vector</code> of messageable type, at receiver side the collection is exposed as <code>gsl::span</code>.</li>
<li><code>std::vector</code> of pointers to messageable type, the objects are linearized in th message and exposed as gsl::span on the receiver side.</li>
</ul>
<p>The <code>DataChunk</code> class resembles a <code>iovec</code>:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>DataChunk {</div><div class="line">  <span class="keywordtype">char</span> *<a class="code" href="../../dc/da3/glcorearb_8h.html#a8922a680b00df660c57f47c1971d04c5">data</a>;</div><div class="line">  <span class="keywordtype">size_t</span> <a class="code" href="../../dc/da3/glcorearb_8h.html#a3d1e3edfcf61ca2d831883e1afbad89e">size</a>;</div><div class="line">};</div></div><!-- fragment --><p>however, no API is provided to explicitly send it. All the created DataChunks are sent (potentially using scatter / gather) when the <code>process</code> function returns. This is to avoid the “modified after send” issues where a message which was sent is still owned and modifiable by the creator.</p>
<h3>Error handling</h3>
<p>When an error happens during processing of some data, the writer of the <code>process</code> function should simply throw an exception. By default the exception is caught by the <code>DataProcessingDevice</code> and a message is printed (if <code>std::exeception</code> derived <code>what()</code> method is used, otherwise a generic message is given). Users can provide themselves an error handler by specifying via the <code>onError</code> callback specified in <code>DataProcessorSpec</code>. This will allow in the future to reinject data into the flow in case of an error.</p>
<h3>Services</h3>
<p>Services are utility classes which <code>DataProcessor</code>s can access to request out-of-bound, deployment dependent, functionalities. For example a service could be used to post metrics to the monitoring system or to get a GPU context. The former would be dependent on whether you are running on your laptop (where monitoring could simply mean print out metrics on the command line) or in a large cluster (where monitoring probably means to send metrics to an aggregator device which then pushes them to the backend.</p>
<p>Services are initialised by the driver code (i.e. the code included via <code>runDataProcessing.h</code>) and passed to the user code via a <code>ServiceRegistry</code>. You can retrieve the service by the type of its interface class. E.g. for Monitoring you can do:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Monitoring/Monitoring.h&gt;</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">auto</span> service = ctx.services().get&lt;<a class="code" href="../../db/dac/DataProcessingDevice_8cxx.html#a5962b957864ccc959e36fe220a433586">Monitoring</a>&gt;(); <span class="comment">// In the DataProcessor lambda...</span></div><div class="line">service.send({ 1, <span class="stringliteral">&quot;my/metric&quot;</span> }); ...</div></div><!-- fragment --><p>Currently available services are described below.</p>
<h4>ControlService</h4>
<p>The control service allow DataProcessors to modify their state or the one of their peers in the topology. For example if you want to quit the whole data processing topology, you can use:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d2/d43/ControlService_8h.html">Framework/ControlService.h</a>&quot;</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="keyword">auto</span> ctx.services().get&lt;ControlService&gt;().readyToQuit(QuitRequest::All) <span class="comment">// In the DataProcessor lambda</span></div></div><!-- fragment --><h4>RawDeviceService</h4>
<p>This service allows you to get an hold of the <code><a class="el" href="../../db/dfe/classFairMQDevice.html">FairMQDevice</a></code> running the DataProcessor computation from with the computation itself. While in general this should not be used, it is handy in case you want to integrate with a pre-existing <code><a class="el" href="../../db/dfe/classFairMQDevice.html">FairMQDevice</a></code> which potentially does not even follow the O2 Data <a class="el" href="../../d6/d18/classModel.html">Model</a>.</p>
<h4>Monitoring service</h4>
<p>Integration with the monitoring subsystem of O2 happens by getting the <code>o2::monitoring::Monitoring</code> interface. <a class="el" href="../../d2/d88/classA.html">A</a> simple example is:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;Monitoring/Monitoring.h&gt;</span></div><div class="line"><span class="comment">// ...</span></div><div class="line"><span class="keyword">auto</span> service = ctx.services().get&lt;<a class="code" href="../../db/dac/DataProcessingDevice_8cxx.html#a5962b957864ccc959e36fe220a433586">Monitoring</a>&gt;(); <span class="comment">// In the DataProcessor lambda...</span></div><div class="line">service.send({ 1, <span class="stringliteral">&quot;my/metric&quot;</span> }); ...</div></div><!-- fragment --><p>for the full API documentation please have a look at:</p>
<p><a href="https://github.com/AliceO2Group/Monitoring">https://github.com/AliceO2Group/Monitoring</a></p>
<p>Some suffix for the metrics are reserved to represent vector and tabular metrics.</p>
<ul>
<li><code>&lt;some-metric-name&gt;/n</code> contains the size of a vector metric at a given moment.</li>
<li><code>&lt;some-metric-name&gt;/m</code> contains the secondary size of a matrix metric at a given moment.</li>
<li><code>&lt;some-metric-name&gt;/&lt;i&gt;</code> where <code>&lt;i&gt;</code> is an integer contains the values of the i-th element in a vector metric or of the <code>&lt;i&gt;n</code> column, <code>&lt;i&gt;/m</code> row of a matrix metric.</li>
</ul>
<h4>Generic Logger</h4>
<p>Generic logging capabilities of DPL are provided via Framework/Logger which wraps and extents FairLogger.</p>
<div class="fragment"><div class="line">{C++}</div><div class="line">#include &quot;Framework/Logger.h&quot;</div><div class="line">...</div><div class="line"></div><div class="line">LOG(INFO) &lt;&lt; &quot;some message&quot;;      // streamer based API</div><div class="line">LOGF(INFO, &quot;%s&quot;, &quot;some message&quot;); // printf based API</div><div class="line">LOGP(INFO, &quot;{}&quot;, &quot;some message&quot;); // python / fmt based API</div><div class="line">O2INFO(&quot;{}&quot;, &quot;some message);      // same but with less typing.</div></div><!-- fragment --><h4>InfoLogger service</h4>
<p>Integration with the InfoLogger subsystem of O2 happens in two way:</p>
<ul>
<li>Explicitly, by getting the <code>AliceO2::InfoLogger::InfoLogger</code> service from the registry, like done in the monitoring case:</li>
</ul>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;InfoLogger/InfoLogger.hxx&gt;</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="keyword">auto</span> logger = context.services().get&lt;InfoLogger&gt;(); <span class="comment">// In the DataProcessor lambda</span></div></div><!-- fragment --><ul>
<li>Implicitly, by using the standard FairLogger <code>LOG</code> macro. In order to enable this the user needs to specify the minimum severity to send to the <code>InfoLogger</code> via the <code>--infologger-severity</code> option, e.g.:</li>
</ul>
<div class="fragment"><div class="line">... --infologger-severity WARNING</div></div><!-- fragment --><p>Finally, one can configure the bahavior of the InfoLogger by using the <code>--infologger-mode</code> option.</p>
<h4>Callback service</h4>
<p><a class="el" href="../../d2/d88/classA.html">A</a> service that data processors can register callback functions invoked by the framework at defined steps in the process flow. This allows you to have customisation points for the following event:</p>
<ul>
<li><code>CallbackService::Id::Start</code>: before entering the running state.</li>
<li><code>CallbackService::Id::Stop</code>: before exiting the running state.</li>
<li><code>CallbackService::Id::Reset</code>: before resetting the device.</li>
</ul>
<p>Moreover in case you want to process events which are not coming from <code>FairMQ</code>, there is a <code>CallbackService::Id::ClockTick</code> which is called according to the rate specified for the backing FairMQ device.</p>
<p>Similarly the <code>CallbackService::Id::Idle</code> callback is fired whenever there was nothing to process.</p>
<p>One last callback is <code>CallbackService::Id::EndOfStream</code>. This callback will be invoked whenever all the upstream DataProcessingDevice consider that they will not produce any more data, so we can finalize our results and exit.</p>
<h2>Expressing parallelism</h2>
<p>If we want to retain a message passing semantic and really treat shared memory as yet another transport, we need to be very careful in how to express parallelism on data, so that the “single ownership model” of message passing forces us to either duplicate streams that need to be accessed in parallel, or to serialise workers which need to access the same data. Solutions like reference counting shared memory would not be allowed in such a scenario and in any case would require extra caution and support to make sure that failures do not leave dangling reference around (e.g. when one of the parallel workers abruptly terminates). First of all let’s consider the fact that there are two level of parallelisms which can be achieved:</p>
<ul>
<li>Data flow parallelism: when data can be split in partitions according to some subdivision criteria (e.g. have one stream per TPC sector and have one worker for each).</li>
<li>Time flow parallelism: when parallelism can be achieved by having different workers handle different time intervals for the incoming data. (e.g. worker 0 processes even timeframes, worker 1 processes odd timeframes).</li>
</ul>
<p>In order to express those DPL provides the <code><a class="el" href="../../dd/d8d/namespaceo2_1_1framework.html#a930799bc13c911ce05e376c5b6c8ac09">o2::framework::parallel</a></code> and <code><a class="el" href="../../dd/d8d/namespaceo2_1_1framework.html#ac23d50376a9780e817bf2f9cc67ade79">o2::framework::timePipeline</a></code> helpers to avoid expressing those explicitly in the workflow.</p>
<h2>Integrating with pre-existing devices</h2>
<p>It can actually happen that you need to interface with native FairMQ devices, either for convenience or because they require a custom behavior which does not map well on top of the Data Processing Layer.</p>
<p>This is fully supported and the DPL provides means to ingest foreign, non-DPL <code><a class="el" href="../../db/dfe/classFairMQDevice.html">FairMQDevice</a></code> produced messages into a DPL workflow. This is done via the help of a "proxy" data processor which connects to the foreign device, receives its inputs, optionally converts them to a format understood by the Data Processing Layer, and then pumps them to the right Data Processor Specs.</p>
<p>This is done using the <code>FairMQRawDeviceService</code> which exposes the actual device on which an Algorithm is running, giving the user full control.</p>
<h2>Customisation of default behavior</h2>
<p>The DPL aims at solving with the default behavior the majority of common usecases. For all the special cases to be handle, we however provide multiple customisation entrypoints, in particular to:</p>
<ul>
<li>Change the policy for when an input record can be processed and what to do with the record afterwards. This is referred as <code>CompletionPolicy</code>.</li>
<li>Change the behavior of the FairMQ channels. This is referred to as <code>ChannelConfigurationPolicy</code>.</li>
<li>Change the command line options of the workflow driver.</li>
</ul>
<p>In all cases this is done by providing a:</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/d90/trackselection_8cxx.html#a1847186994155009dc39999a652c9b3d">customize</a>(...)</div></div><!-- fragment --><p>free function which takes as argument the group of policies to be applied to customise the behavior.</p>
<h2>Managing multiple workflows.</h2>
<p>In general a DPL workflow consists of a C++ executable which defines an implicit workflow, as previously discribed. However it is sometimes handy to be able to split workflow in parts, e.g. to be able to run two detectors independently or to have a basic workflow with is then decorated with extra processing like data sampling if / when requested.</p>
<p>DPL allows merging workflows by simply piping one into the other. So if <code>workflow-a</code> and <code>workflow-b</code> are two separate workflows, one can run the union of the two by doing:</p>
<div class="fragment"><div class="line">workflow-a | workflow-b</div></div><!-- fragment --><p>Because the merging happens at the level of the implicit representation, this allows having dangling inputs and outputs which are potentially satisfied only when a separate workflow is merged.</p>
<h1>Forward looking statements:</h1>
<h2>Support for analysis</h2>
<p>While not part of the initial design goal, we plan to extend DPL in order to support analysis. In particular we are evaluating a mode in which users can natively get a <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a> <code>RDataFrame</code> with an API similar to the <code>InputRecord</code> API.</p>
<h2>Provenance dependent matching of inputs and outputs</h2>
<p>By default the Input and Outputs are matched solely by the signature of the data they contain. However sometimes it's desirable that this matching happens based on the history that a given message had, e.g. if it went through one path or another of a dataflow bifurcation. While this is not at the moment supported and you would have to use a separate data type for the two different origins, the usecase is acknowledged and will be addressed in a future revision of this document.</p>
<h2>Support for non compiled, non C++, based configuration</h2>
<p>At the moment the configuration of a topology is done by compiling a declarative description of the computation done in C++, and by running the resulting executable. This is however an implementation detail and the datamodel for the configuration description is meant to be agnostic from the language. We foresee both using interpreted configurations (e.g. via <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a> / cling) or configurations done through another language (e.g. go, javascript).</p>
<h1>Current Demonstrator</h1>
<p><a class="el" href="../../d2/d88/classA.html">A</a> demonstrator illustrating a possible implementation of the design described above is now found in the dev branch of AliceO2, in the Framework folder.</p>
<p>In particular:</p>
<ul>
<li><code>Framework/Core</code> folder contains the <code>DataProcessorSpec</code> class and related.</li>
<li><code>Framework/Core/test</code> folder contains a few unit test and simple example workflows.</li>
<li><code>Framework/TestWorkflows</code> folder contains a few example workflows.</li>
<li><code>Framework/DebugGUI</code> folder contains the core GUI functionalities.</li>
<li><code>Framework/Utils</code> folder contains utilities and helpers for the creation of workflows.</li>
</ul>
<p>There is also a few demonstrator available in particular:</p>
<ul>
<li><a href="https://github.com/AliceO2Group/AliceO2/tree/dev/Detectors/TPC/workflow">https://github.com/AliceO2Group/AliceO2/tree/dev/Detectors/TPC/workflow</a> demonstrates the usage of DPL for TPC clusterisation and track reconstruction.</li>
<li><a href="https://github.com/AliceO2Group/AliceO2/blob/dev/Framework/TestWorkflows/src/o2SyncReconstructionDummy.cxx">https://github.com/AliceO2Group/AliceO2/blob/dev/Framework/TestWorkflows/src/o2SyncReconstructionDummy.cxx</a> provides a skeleton for the synchronous reconstruction.</li>
<li><a href="https://github.com/AliceO2Group/AliceO2/tree/dev/Steer/DigitizerWorkflow">https://github.com/AliceO2Group/AliceO2/tree/dev/Steer/DigitizerWorkflow</a> provides a workflow than can do TPC digitisation.</li>
</ul>
<h2>Interesting reads</h2>
<ul>
<li><a href="https://research.google.com/pubs/pub41378.html">MillWheel: Fault-Tolerant Stream Processing at Internet Scale</a> : paper about Google previous generation system for stream processing</li>
</ul>
<h2>Data Sampling</h2>
<p>Data Sampling provides possibility to sample data in DPL workflows, basing on certain conditions ( 5% randomly, when payload is greater than 4234 bytes, etc.). The job of passing the right data is done by a data processor called <code>Dispatcher</code>. <a class="el" href="../../d2/d88/classA.html">A</a> desired data stream is specified in form of Data Sampling Policies, configured by JSON structures (example below). </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;id&quot;: &quot;policy_example1&quot;,              # name of the policy</div><div class="line">  &quot;active&quot;: &quot;false&quot;,                    # activation flag</div><div class="line">  &quot;machines&quot;: [                         # list of machines where the policy should be run (now ignored)</div><div class="line">    &quot;aido2flp1&quot;,</div><div class="line">    &quot;aido2flp2&quot;</div><div class="line">  ],                                    # list of data that should be sampled, the format is:</div><div class="line">                                        # binding1:origin1/description1/subSpec1[;binding2:...]</div><div class="line">  &quot;query&quot;: &quot;clusters:TPC/CLUSTERS/0;tracks:TPC/TRACKS/0&quot;,</div><div class="line">  &quot;samplingConditions&quot;: [               # list of sampling conditions</div><div class="line">    {</div><div class="line">      &quot;condition&quot;: &quot;random&quot;,            # condition type</div><div class="line">      &quot;fraction&quot;: &quot;0.1&quot;,                # condition-dependent parameter: fraction of data to sample</div><div class="line">      &quot;seed&quot;: &quot;2112&quot;                    # condition-dependent parameter: seed of PRNG</div><div class="line">    }</div><div class="line">  ],</div><div class="line">  &quot;blocking&quot;: &quot;false&quot;                   # should the dispatcher block the main data flow? (now ignored)</div><div class="line">}</div></div><!-- fragment --><h3>Usage</h3>
<p>To use Data Sampling in a DPL workflow insert following lines to your code: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../d7/d78/DataSampling_8h.html">Framework/DataSampling.h</a>&quot;</span></div><div class="line"><span class="keyword">using namespace </span><a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html">o2::framework</a>;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/d90/trackselection_8cxx.html#a1847186994155009dc39999a652c9b3d">customize</a>(std::vector&lt;CompletionPolicy&gt;&amp; policies)</div><div class="line">{</div><div class="line">  <a class="code" href="../../d1/d54/classo2_1_1framework_1_1DataSampling.html#ae06f39123df4012614827ff4ada52195">DataSampling::CustomizeInfrastructure</a>(policies);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> <a class="code" href="../../db/d90/trackselection_8cxx.html#a1847186994155009dc39999a652c9b3d">customize</a>(std::vector&lt;ChannelConfigurationPolicy&gt;&amp; policies)</div><div class="line">{</div><div class="line">  <a class="code" href="../../d1/d54/classo2_1_1framework_1_1DataSampling.html#ae06f39123df4012614827ff4ada52195">DataSampling::CustomizeInfrastructure</a>(policies);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="../../db/dd0/runDataProcessing_8h.html">Framework/runDataProcessing.h</a>&quot;</span></div><div class="line"></div><div class="line">std::vector&lt;DataProcessorSpec&gt; <a class="code" href="../../d5/d75/centralityQa_8cxx.html#af7d4c4ac874e3b6bf3dcb688a4c64b1b">defineDataProcessing</a>(<a class="code" href="../../d0/dab/classo2_1_1framework_1_1ConfigContext.html">ConfigContext</a> &amp;ctx)</div><div class="line">{</div><div class="line"></div><div class="line"> <a class="code" href="../../dd/d8d/namespaceo2_1_1framework.html#a7daf5fb16896e1e754a18cfcf37e665b">WorkflowSpec</a> workflow;</div><div class="line"><span class="comment">// &lt;declaration of other DPL processors&gt;</span></div><div class="line"></div><div class="line"> <a class="code" href="../../d1/d54/classo2_1_1framework_1_1DataSampling.html#a88230b77c4a87079a89629727abb161b">DataSampling::GenerateInfrastructure</a>(workflow, <span class="stringliteral">&quot;json:///absolute/path/to/config/file.json&quot;</span>);</div><div class="line"></div><div class="line"> <span class="keywordflow">return</span> workflow;</div><div class="line">}</div></div><!-- fragment --><p>Sampled data can be subscribed to by adding <code>InputSpecs</code> provided by <code>std::vector&lt;InputSpec&gt; DataSampling::InputSpecsForPolicy(const std::string&amp; policiesSource, const std::string&amp; policyName)</code> to a chosen data processor. Then, they can be accessed by the bindings specified in the configuration file. Dispatcher adds a <code>DataSamplingHeader</code> to the header stack, which contains statistics like total number of evaluated/accepted messages for a given Policy or the sampling time since epoch.</p>
<p><a href="https://github.com/AliceO2Group/AliceO2/blob/dev/Framework/TestWorkflows/src/dataSamplingPodAndRoot.cxx">o2-datasampling-pod-and-root</a> workflow can serve as usage example.</p>
<h2>Data Sampling Conditions</h2>
<p>The following sampling conditions are available. When more than one is used, a positive decision is taken when all the conditions are fulfilled.</p><ul>
<li><b>DataSamplingConditionRandom</b> - pseudo-randomly accepts specified fraction of incoming messages. <div class="fragment"><div class="line">{</div><div class="line">  &quot;condition&quot;: &quot;random&quot;,</div><div class="line">  &quot;fraction&quot;: &quot;0.1&quot;,</div><div class="line">  &quot;seed&quot;: &quot;22222&quot;</div><div class="line">}</div></div><!-- fragment --></li>
<li><b>DataSamplingConditionNConsecutive</b> - approves n consecutive samples in defined cycle. It assumes that timesliceID always increments by one. <div class="fragment"><div class="line">{</div><div class="line">  &quot;condition&quot;: &quot;nConsecutive&quot;,</div><div class="line">  &quot;samplesNumber&quot;: &quot;3&quot;,</div><div class="line">  &quot;cycleSize&quot;: &quot;100&quot;</div><div class="line">}</div></div><!-- fragment --></li>
<li><b>DataSamplingConditionPayloadSize</b> - approves messages having payload size within specified boundaries. <div class="fragment"><div class="line">{</div><div class="line">  &quot;condition&quot;: &quot;payloadSize&quot;,</div><div class="line">  &quot;lowerLimit&quot;: &quot;300&quot;,</div><div class="line">  &quot;upperLimit&quot;: &quot;500&quot;</div><div class="line">}</div></div><!-- fragment --></li>
<li><b>DataSamplingConditionCustom</b> - loads a custom condition, which should inherit from DataSamplingCondition, from a specified library. <div class="fragment"><div class="line">{</div><div class="line">  &quot;condition&quot;: &quot;custom&quot;,</div><div class="line">  &quot;moduleName&quot;: &quot;QcExample&quot;,</div><div class="line">  &quot;className&quot;: &quot;o2::quality_control_modules::example::ExampleCondition&quot;,</div><div class="line">  &quot;customParam&quot;: &quot;value&quot;</div><div class="line">}</div></div><!-- fragment --> <h2>Document history</h2>
</li>
</ul>
<ul>
<li>v0.9: proposal for approval at the O2 TB - 19th June 2018 </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d3a/refFramework.html">Module &#39;Framework&#39;</a></li>
    <li class="footer">Generated on Thu Jun 4 2020 09:30:40 for Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
