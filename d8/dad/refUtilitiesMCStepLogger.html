<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: MCStepLogger</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d8/dad/refUtilitiesMCStepLogger.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">MCStepLogger </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h3>NOTE: The MCStepLogger has moved to <a href="https://github.com/AliceO2Group/VMCStepLogger.git">https://github.com/AliceO2Group/VMCStepLogger.git</a></h3>
<h2>MCStepLogger</h2>
<p>Detailed debug information about stepping can be directed to standard output using the <code>LD_PRELOAD</code> env variable, which "injects" a special logging library (which intercepts some calls) in the executable that follows in the command line.</p>
<div class="fragment"><div class="line">LD_PRELOAD=path_to/libMCStepLogger.so o2sim -m MCH -n 10</div></div><!-- fragment --><div class="fragment"><div class="line">[MCLOGGER:] START FLUSHING ----</div><div class="line">[STEPLOGGER]: did 28 steps</div><div class="line">[STEPLOGGER]: transported 1 different tracks</div><div class="line">[STEPLOGGER]: transported 1 different types</div><div class="line">[STEPLOGGER]: VolName cave COUNT 23 SECONDARIES 0</div><div class="line">[STEPLOGGER]: VolName normalPCB1 COUNT 3 SECONDARIES 0</div><div class="line">[STEPLOGGER]: ----- END OF EVENT ------</div><div class="line">[FIELDLOGGER]: did 21 steps</div><div class="line">[FIELDLOGGER]: VolName cave COUNT 20</div><div class="line">[FIELDLOGGER]: ----- END OF EVENT ------</div><div class="line">[MCLOGGER:] END FLUSHING ----</div></div><!-- fragment --><p>The stepping logger information can also be directed to an output tree for more detailed investigations. Default name is <code>MCStepLoggerOutput.root</code> (and can be changed by setting the <code>MCSTEPLOG_OUTFILE</code> env variable).</p>
<div class="fragment"><div class="line">MCSTEPLOG_TTREE=1 LD_PRELOAD=path_to/libMCStepLogger.so o2sim ..</div></div><!-- fragment --><p>Finally the logger can use a map file to give names to some logical grouping of volumes. For instance to map all sensitive volumes from a given detector <code>DET</code> to a common label <code>DET</code>. That label can then be used to query information about the detector steps "as a whole" when using the <code>StepLoggerTree</code> output tree.</p>
<div class="fragment"><div class="line">&gt; cat volmapfile.dat</div><div class="line">normalPCB1 MCH</div><div class="line">normalPCB2 MCH</div><div class="line">normalPCB3 MCH</div><div class="line">normalPCB4 MCH</div><div class="line">normalPCB5 MCH</div><div class="line">normalPCB6 MCH</div><div class="line">centralPCB MCH</div><div class="line">downroundedPCB MCH</div><div class="line">uproundedPCB MCH</div><div class="line">cave TheCavern</div><div class="line"></div><div class="line">&gt; MCSTEPLOG_VOLMAPFILE=path_to_/volmapfile.dat MCSTEPLOG_TTREE=1 LD_PRELOAD=path_to/libMCStepLogger.so o2sim ..</div><div class="line"></div><div class="line">&gt; root -b MCStepLoggerOutput.root</div><div class="line">root[0] StepLoggerTree-&gt;Draw(&quot;Lookups.volidtomodule.data()&quot;);</div></div><!-- fragment --><p>Note also the existence of the <code>LD_DEBUG</code> variable which can be used to see in details what libraries are loaded (and much more if needed...).</p>
<div class="fragment"><div class="line">LD_DEBUG=libs o2sim</div><div class="line">LD_DEBUG=help o2sim</div></div><!-- fragment --><h2>Special case on macOS</h2>
<p><code>LD_PRELOAD</code> must be replaced by <code>DYLD_INSERT_LIBRARIES</code>, e.g. :</p>
<div class="fragment"><div class="line">DYLD_INSERT_LIBRARIES=/Users/laurent/alice/sw/osx_x86-64/O2/latest-clion-o2/lib/libMCStepLogger.dylib MCSTEPLOG_TTREE=1 MCSTEPLOG_OUTFILE=toto.root o2sim -m MCH -g mugen -n 1</div></div><!-- fragment --><p><code>LD_DEBUG=libs</code> must be replaced by <code>DYLD_PRINT_LIBRARIES=1</code></p>
<p><code>LD_DEBUG=statistics</code> must be replaced by <code>DYLD_PRINT_STATISTICS=1</code></p>
<h2>MCStepLogAnalysis</h2>
<p>Information collected and stored in <code>MCStepLoggerOutput.root</code> can be further investigated using the excutable <code>mcStepAnalysis</code>. This executable is independent of the simulation itself and produces therefore no overhead when running a simulation. 2 commands are so far available (<code>analyze</code>, <code>checkFile</code>) including useful help message when typing </p><div class="fragment"><div class="line">mcStepAnalysis &lt;command&gt; --help</div></div><!-- fragment --><h3>File formats</h3>
<p>2 file formats having a standardised structure play a role. On one hand, these are the files produced by the step logging which are the input files for the analysis as explained in the following. On the other hand, each analysis produces an output file containing histograms along with some meta information. Sanity and the type of the file can be checked via </p><div class="fragment"><div class="line">mcStepAnalysis checkFile -f &lt;FileToBeChecked&gt;</div></div><!-- fragment --> <h3>Analysing the steps</h3>
<p>The basic command containing all required parameters is </p><div class="fragment"><div class="line">mcStepAnalysis analyze -f &lt;MCStepLoggerOutputFile&gt; -o &lt;parent/output/dir&gt; -l &lt;label&gt;</div></div><!-- fragment --><p> where</p><ul>
<li><code>-f &lt;MCStepLoggerOutputFile&gt;</code> passes the input file produced with the <code>MCStepLogger</code> as explained above (default name is <code>MCStepLoggerOutput.root</code>)</li>
<li><code>-o &lt;parent/output/dir&gt;</code> provides the top directory for the analysis output (if this does not exist, it is created automatically)</li>
<li><code>-l &lt;label&gt;</code> adds a label, e.g. for plots produced later.</li>
</ul>
<p><a class="el" href="../../d2/d88/classA.html">A</a> <code><a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a></code> file at <code>parent/output/dir/MetaAnalysis/Analysis.root</code> is produced containing all histograms as well as important meta information. Histogram objects are derived from <code><a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a></code>s <code>TH1</code> classes.</p>
<h3>Further processing of analysis files</h3>
<p>Files produced as described before can be investigated further or used to plot the histograms therein. The interface to read these files is the class <code>AnalysisFile</code> and histograms can be requested by their names. </p><div class="fragment"><div class="line"><span class="comment">// somthing...</span></div><div class="line"><span class="preprocessor">#include &quot;MCStepLogger/AnalysisFile.h&quot;</span></div><div class="line"><span class="comment">// some code</span></div><div class="line">AnalysisFile af;</div><div class="line">af.read(<span class="stringliteral">&quot;path/to/file.root&quot;</span>);</div><div class="line"><span class="comment">// print meta info</span></div><div class="line">af.printMetaInfo();</div><div class="line"><span class="comment">// get a histogram by name (program will exit if name not found)</span></div><div class="line">TH1&amp; histogram = af.getHistogram(<span class="stringliteral">&quot;nameOfHistogram&quot;</span>);</div><div class="line"><span class="comment">// if you know the underlying object is, e.g. of derived class TH1D and you really need that you can do</span></div><div class="line">TH1D&amp; otherHistogramCasted = af.getHistogram&lt;TH1D&gt;(<span class="stringliteral">&quot;nameOfOtherHistogram&quot;</span>);</div><div class="line"><span class="comment">// where the program will safely exit immediately in case the casting was not successful</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">// modify histogram or do other things</span></div><div class="line"><span class="comment">//...</span></div><div class="line"><span class="comment">//to save changes made to histograms do</span></div><div class="line">af.write(<span class="stringliteral">&quot;path/to/output/file.root&quot;</span>);</div></div><!-- fragment --> <h3>Additional information about the <code>MCAnalysisManager</code></h3>
<p>There is the staic method <code>MCAnalysisManager::Instance()</code> which returns a reference to a static instance. So always make sure you don't copy it but get the reference in case you want to work with that instance on a global scope, i.e. </p><div class="fragment"><div class="line"><span class="comment">// some code</span></div><div class="line"><span class="keyword">auto</span>&amp; anamgr = MCAnalysisManager::Instance();</div></div><!-- fragment --> <h3>Additional information about the analysis objects</h3>
<p>Histograms which should be written to disk in an analysis are managed by <code>MCAnalysisFileWrapper</code> objects. These also make sure that no histogram is created twice. Therefore, all of these histograms should be created like <code>T* myHisto = MCAnalysis::getHistogram&lt;<a class="el" href="../../d1/def/classT.html">T</a>&gt;(...)</code> where the template parameter <code><a class="el" href="../../d1/def/classT.html">T</a></code> must be a class deriving from <a class="el" href="../../d0/d10/namespaceROOT.html">ROOT</a>'s <code>TH1</code>. It then returns a pointer to the desired object. Managing histograms not on the level of an analysis also enables for requesting histograms from another analysis. In that way one can write a custom analysis for a specific use case but can still ask for e.g. for a histogram from the <code>BasicMCAnalysis</code> to derive some additional and more generic information about a simulation run. Hence, never manually delete an object obtained like this.</p>
<h3>Comparing analysis values to reference reference values</h3>
<p>For the <code>BasicMCAnalysis</code> there is a small test suite to compare the obtained values from a simulation run to reference values contained in a JSON file. So far, that is a prototype only caring about the total number of steps and total number of tracks obtained in the simulation. The <code>JSON</code> file looks as follows </p><div class="fragment"><div class="line">{</div><div class="line">  &quot;analysisName&quot;: &quot;BasicMCAnalysis&quot;,</div><div class="line">  &quot;nSteps&quot;: [absoluteNumberOfSteps, relativeTolerance],</div><div class="line">  &quot;nTracks&quot;: [absoluteNumberOfTracks, relativeTolerance]</div><div class="line">}</div></div><!-- fragment --><p> The test is steered via </p><div class="fragment"><div class="line">runTestBasicMCAnalysis -- &lt;path/to/Analysis.root&gt; &lt;reference.json&gt;</div></div><!-- fragment --><p> Note, that the test does not know anything about the settings of the simulation run, i.e. there are no information about the primary generator of the transport engine etc. The user has to make sure to apply this coherently.</p>
<h3>Writing/running a custom analysis</h3>
<p>Although providing already a number of different observables, users might want to add custom observables for their analysis. To do so, a directory for custom analyses has to be created where analysis macros can be provided and loaded at run-time. Note, that only the basic analysis is actually contained in the compiled code. One of the main reasons for that is to enable for a coherent comparison between different points in the git history. However, if you feel like there is an important observable missing, feel free to report that.</p>
<p>The logic of adding a custom analysis is very similar to that of <code>Rivet</code> and the general workflow should look familiar in any case. Say, your analysis macro directory is <code>$ANALYSIS_MACROS/</code> where you have your macro <code>mySimulationAnalysisc.C</code> (don't place any other files there since these cannot be read...). <a class="el" href="../../d2/d88/classA.html">A</a> skeleton looks as follows, also containing more information on how and why things are implemented like they are:</p>
<div class="fragment"><div class="line"><span class="comment">// myMCStepAnalysis.C</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// headers you need</span></div><div class="line"></div><div class="line"><span class="comment">/* Your analysis class has to derive from the base o2::mcstepanalysis::MCAnalysis. All</span></div><div class="line"><span class="comment"> * methods to be implemented are mentioned below.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">class </span>MyMCStepAnalysis : <span class="keyword">public</span> MCAnalysis</div><div class="line">{</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    <span class="comment">/* You don&#39;t need a fancy constructor, that&#39;s it. The base constructor takes care</span></div><div class="line"><span class="comment">     * of registering this analysis to the global o2::MCStepAnalysis::MCAnalysisManager</span></div><div class="line"><span class="comment">     * object. An MCAnalysis object cannot exist without the MCAnalysisManager.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    MySimulationAnalysis()</div><div class="line">      : MCAnalysis(<span class="stringliteral">&quot;MyMCStepAnalysis&quot;</span>)</div><div class="line">    {}</div><div class="line"></div><div class="line">    <span class="comment">/* There are 3 methods covering the analysis: initialize, analyze and finalize.</span></div><div class="line"><span class="comment">     * The first two need to be overriden in any case.</span></div><div class="line"><span class="comment">     * These methods are called by the MCAnalysisManager. Other custom methods</span></div><div class="line"><span class="comment">     * can hence only be used for class-internal purposes only.</span></div><div class="line"><span class="comment">     */</span></div><div class="line"></div><div class="line">    <span class="comment">/* All histograms used in the analysis must be defined here. This is done using</span></div><div class="line"><span class="comment">     * the method MCAnalysis::getHistogram&lt;T&gt;(...) where the template paramter T has to</span></div><div class="line"><span class="comment">     * be a deriving class of ROOT&#39;s TH1. The histogram pointers are the managed</span></div><div class="line"><span class="comment">     * globally for further processing, saving, plotting etc. It is also taken care</span></div><div class="line"><span class="comment">     * of the deletion of the pointers. Do not attempt to delete histograms obtained by</span></div><div class="line"><span class="comment">     * MCAnalysis::getHistogram&lt;T&gt;(...). Histograms are uniquely identified by there</span></div><div class="line"><span class="comment">     * name and an MCAnalysis will stop immediately at the initialisation stage if</span></div><div class="line"><span class="comment">     * two histograms with the same name are detected.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordtype">void</span> initialize()<span class="keyword"> override </span>{</div><div class="line"></div><div class="line">      <span class="comment">// monitor calls to the magnetic field per volume</span></div><div class="line">      histMyFirstObservable = getHistogram&lt;TH1D&gt;(<span class="stringliteral">&quot;myFirstObservable&quot;</span>, 1, 0., 1.);</div><div class="line">      <span class="comment">// monitor the steps in the r-z plane</span></div><div class="line">      histMySecondObservable = getHistogram&lt;TH2D&gt;(<span class="stringliteral">&quot;mySecondObservable&quot;</span>, 1, 0., 1., 2, 0., 2.);</div><div class="line">      <span class="comment">// more histograms?! Other things to do?</span></div><div class="line"></div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* This method is used to extract the step information in order to fill histograms</span></div><div class="line"><span class="comment">     * accordingly.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordtype">void</span> analyze(<span class="keyword">const</span> std::vector&lt;StepInfo&gt;* <span class="keyword">const</span> steps,</div><div class="line">                 <span class="keyword">const</span> std::vector&lt;MagCallInfo&gt;* <span class="keyword">const</span> magCalls)<span class="keyword"> override </span>{</div><div class="line"></div><div class="line">      <span class="comment">// loop over mag field calls and match to step ID</span></div><div class="line">      <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; call : *magCalls) {</div><div class="line">        <span class="keyword">auto</span> step = steps-&gt;operator[](call.stepid);</div><div class="line">        mAnalysisManager-&gt;getLookupVolName(step.volId, volName);</div><div class="line">        histMyFirstObservable-&gt;Fill(volName.c_str(), 1.);</div><div class="line">      }</div><div class="line"></div><div class="line">      <span class="comment">// loop over steps and get z-position and other things as you like</span></div><div class="line">      <span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span>&amp; step : *steps) {</div><div class="line">        histMySecondObservable-&gt;Fill(step.z, std::sqrt( step.x*step.x + step.y*step.y ));</div><div class="line">        <span class="comment">// ...and do more, as you like</span></div><div class="line">      }</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">/* the finalyze method can be used to do necessary adjustments like scaling or adding</span></div><div class="line"><span class="comment">     * histograms or whatever must be done to them.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    <span class="keywordtype">void</span> finalize()<span class="keyword"> override </span>{</div><div class="line">      histMyFirstObservable-&gt;Scale( 1. / histMyFirstObservable-&gt;GetEntries() );</div><div class="line">      <span class="comment">// ...and more...</span></div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="comment">// you might want to provide some useful methods for internal use...</span></div><div class="line"></div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    TH1D* histMyFirstObservable;</div><div class="line">    TH2D* histMySecondObservable;</div><div class="line">    <span class="comment">// other histogram pointers and/or members for internal usage</span></div><div class="line"> };</div><div class="line"></div><div class="line"><span class="comment">/* The hook to bring your analysis into existence so that the MCAnalysisManager</span></div><div class="line"><span class="comment"> * knows. Don&#39;t be scared about the way the pointer of the analysis is created. It is all</span></div><div class="line"><span class="comment"> * taken care of by the MCAnalysisManager since the base MCAnalysis constructor</span></div><div class="line"><span class="comment"> * automatically registeres itself to the MCAnalysisManager. So don&#39;t worry about</span></div><div class="line"><span class="comment"> * pointers flying around.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> declareAnalysis() {</div><div class="line">  <span class="keyword">new</span> MySimulationAnalysis(<span class="stringliteral">&quot;mySimulationAnalysis&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p> After having this, you are ready to include this in the analysis run by typing </p><div class="fragment"><div class="line">runMCAnalysis analyze -f &lt;MCStepLoggerOutputFile&gt; -o &lt;parent/output/dir&gt; -l &lt;label&gt; -d $ANALYSIS_MACROS -a mySimulationAnalysis</div></div><!-- fragment --><p> where now</p><ul>
<li><code>-d $ANALYSIS_MACROS</code> points the executable to the directory of where your macros are located</li>
<li><code>-a mySimulationAnalysis</code> tells which analysis to load. In case you have more analyses in that directory you want to load, just append the names of all analyses you want to run. The output of the custom analysis is written to <code>parent/output/dir/mySimulationAnalysis/</code> and that's it. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d4/d23/refUtilities.html">Module &#39;Utilities&#39;</a></li>
    <li class="footer">Generated on Thu Jun 4 2020 09:30:40 for Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
