<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Project: /home/travis/build/AliceO2Group/AliceO2/Framework/Core/README.md Source File</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../o2_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('d8/d11/Framework_2Core_2README_8md.html','../../');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/travis/build/AliceO2Group/AliceO2/Framework/Core/README.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="../../d8/d11/Framework_2Core_2README_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;&lt;!-- doxy</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;\page refFrameworkCore Core</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;\subpage refFrameworkCoreCOOKBOOK Core COOKBOOK</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;\subpage refFrameworkCoreANALYSIS Core ANALYSIS</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;/doxy --&gt;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;# Data Processing Layer in O2 Framework</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;## Status quo and motivation for an O2 Data Processing Layer</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;FairMQ currently provides a well documented and flexible framework for an actor based computation where each of the actors listens for message-like entities on channels and executes some code as a reaction. The key component which controls this is called a `FairMQDevice` (or *device* from now on) which can use different kind of transports to receive and send messages. In the most generic case, users are allowed to have full control on the state machine governing the message passing and have complete control on how the message handling is done. This of course covers all ALICE usecases in a generic manner, at the cost of extra complexity left to the user to implement. In most cases however a simplified way of creating devices is provided, and the user will simply create its own `FairMQDevice`-derived class, which registers via the `OnData(FairMQParts &amp;parts)` method a callback that is invoked whenever a new message arrives. This however still holds the user responsible for:</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;* Verifying that the required inputs for the computation are all available, both from the actual data flow (being it for readout, reconstruction or analysis) and from the asynchronous stream (e.g. alignment and calibrations).</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;* Create the appropriate message which holds the results and send it.</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;* Ensure the ease of testability, the code reuse and the proper documentation `OnData` callback. In particular there is no way to inspect which data is expected by a device and which data is produced.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;This is by design, because the FairMQ transport layer should not know anything about the actual data being transferred, while all the points above require some sort of inner knowledge about the data model and the data being moved around.</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;The aim is to achieve the following:</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;* **Explicit data flow:** Input and outputs are declared upfront and can be used for documentation or for automatic topology creation (assuming the actual processing environment is known).</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;* **Transport agnostic data processing:** users will not have to know about the details of how the data materialises on their device, they will always be handed the full set of payloads they requested, even if they come at different time.</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;* **Composability of data processing:** different process functions can in principle be chained and scheduled together depending on the desired granularity for devices.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;## Separating data-processing from transport</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;For the reasons mentioned above, we propose that the one of the developments which should happen with the O2 Framework work package is the development of a “Data Processing layer” which actually knows about the O2 Data Model (and for this reason cannot be part of FairMQ itself) and exploits it to validate, optimise and correctly schedule a computation on a user specified set of inputs.</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;The Data Processing Layer in particular requires:</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;* That the inputs types of each computation are provided upfront.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;* That the outputs types of each computation are provided upfront.</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;* That a time identifier can be associated to inputs</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;and given these premises it actually guarantees:</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;* That whenever a new input arrives a `CompletionPolicy` is executed to decide wether the associate record is complete. By default such a `CompletionPolicy` waits for all the specified parts to have arrived.</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;* That no message passing happens during the performing of the computation, but uniquely at the end.</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;### Instanciating a workflow</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;The description of the computation in such the Data Processing Layer is done via instances of the `DataProcessorSpec` class, grouped in a so called `WorkflowSpec` instance. In order to provide a description a computation to be run, the user must implement a callback which return an filled `WorkflowSpec`. E.g.:</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;```cpp</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;#include &quot;Framework/Utils/runDataProcessing.h&quot;</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;WorkflowSpec defineDataProcessing(ConfigContext &amp;context) {</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;  return WorkflowSpec {</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    DataProcessorSpec{</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;      ...</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;    },</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    DataProcessorSpec{</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;      ...</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    }</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;  };</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;};</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;```</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;See next section, for a more detailed description of the `DataProcessorSpec` class. The code above has to be linked into a single executable together with the Data Processing Layer code to form a so called driver executable which if run will:</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;* Map all `DataProcessorSpec` to a set of `FairMQDevice`s (using 1-1 correspondence, in the current implementation).</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;* Instanciate and start all the devices resulted from the previous step.</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;* (Optionally) start a GUI which allows to monitor the running of the system.</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;The `ConfigContext` object being passed to the function contains a set of user provided options to customise the creation of the workflow. For example you might want to change the number of workers for a given task or disable part of the topology if a given detector should not be enabled.</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;In order to specify which options are to be present in the `ConfigContext`, the user can define the extension point:</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;```cpp</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;void customize(std::vector&lt;o2::framework::ConfigParamSpec&gt; &amp;workflowOptions)</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;```</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;### Describing a computation</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;The description of the computation in such a layer is done via a `DataProcessorSpec` class, which describes some sort of processing of a (set of) O2 Data Payloads (*payloads* from now on), as defined by the O2 Data Model, eventually producing new payloads as outputs. The inputs to the computation, the outputs and the actual code to run on the former to produce the latter, is specified in a `DataProcessorSpec` instance. Multiple `DataProcessorSpec` instances can be grouped together in a `WorkflowSpec`to the driver code which maps them to  processing devices accordingly. </div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;The `DataProcessorSpec` is defined as follows:</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;```cpp</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;struct DataProcessorSpec {</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;   using InitCallback = std::function&lt;ProcessCallback(InitContext &amp;)&gt;;</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;   using ProcessCallback = std::function&lt;void(ProcessingContext &amp;)&gt;;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;   using ErrorCallback = std::function&lt;void(ErrorContext &amp;)&gt;;</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;   std::vector&lt;InputSpec&gt; inputs;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;   std::vector&lt;OutputSpec&gt; outputs;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;   std::vector&lt;ConfigParamSpec&gt; configParams;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;   std::vector&lt;std::string&gt; requiredServices;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;   AlgorithmSpec algorithm;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;};</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;```</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;the inputs field represents a set of subscriptions to some kind of input data we would like to process. As per O2 Data Model</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;there is 3 major properties O2 attaches to a message: its origin, a description and a generic subspecification.</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;So:</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    {InputSpec{&quot;clusters&quot;, &quot;TPC&quot;, &quot;CLUSTERS&quot;, 0}}</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;really means &quot;subscribe in input to the messages which have origin &quot;TPC&quot;, contain objects of kind &quot;CLUSTERS&quot; and have a generic </div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;subspecification 0 (e.g. to index the sector). In your code you will be able to retrieve these kind of messages using the &quot;clusters&quot;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;label (see later the description of the InputRecord API).An InputSpec is effectively a three dimensional selection on space defined by all the possible origins, descriptions and subspecifications.</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;Notice that the method `o2::framework::select` can be used to provide the query</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;in a more compact (and flexible way). Using such an helper the above becomes:</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;     select(&quot;clusters:TPC/CLUSTERS/0&quot;)</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;Similarly the `OutputSpec` is a description of what the DataProcessor will produce, again in terms of (origin, description, subspecification) properties.</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;The `configParams` vector would be used to specify which configuration options the data processing being described requires:</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;```cpp</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;struct ConfigParamSpec {</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;  std::string name;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  enum ParamType type;</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  variant defaultValue;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  ...</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;};</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;```</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;command line / configuration options would be automatically generated by it. These are available only at init stage, and can be used to configure services. They are not available to the actual `process` callback as all the critical parameters for data processing should be part of the data stream itself, eventually coming from CCDB / ParameterManager.</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;Similarly the `requiredServices` vector would define which services are required for the data processing. For example this could be used to declare the need for some data cache, a GPU context, a thread pool.</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;The `algorithm` property, of `AlgorithmSpec` is instead used to specify the actual computation. Notice that the same `DataProcessorSpec` can use different `AlgorithmSpec`. The rationale for this is that while inputs and outputs might be the same, you might want to compare different versions of your algorithm. The `AlgorithmSpec` resembles the following:</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;```cpp</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;struct AlgorithmSpec {</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  using ProcessCallback = std::function&lt;void(ProcessingContext &amp;)&gt;;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  using InitCallback = std::function&lt;ProcessCallback(InitContext &amp;)&gt;;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  using ErrorCallback = std::function&lt;void(ErrorContext &amp;)&gt;;</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  InitCallback onInit = nullptr;</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  ProcessCallback onProcess = nullptr;</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;  ErrorCallback onError = nullptr;</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  ...</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;};</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;```</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;The `onProcess` function is to be used for stateless computations. It’s a free function and it’s up to the framework to make sure that all the required components are declared upfront. It takes as input the context for the current computation in the form of a `ProcessingContext &amp;` instance. Such a context consist of:</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;* An `InputRecord` which allows retrieving the current inputs matching the provided specification.</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;* A `ServiceRegistry` referencing the set of services it declared as required the computation.</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;* A `DataAllocator` allocator which can allocate new payloads only for the types which have been declared as `outputs`.</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;#### Stateful processing</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;`onProcess` is useful whenever your computation is fully contained in your input. In several cases, however, a computation requires some ancillary state, which needs to be initialised only on (re-)start of the job. For example you might want to initialise the geometry of your detector or open a file for reading. To do so, you can use the `onInit` callback, create the state in it and pass it to the returned `ProcessCallback` as captured arguments.</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;E.g:</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;```cpp</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;AlgorithmSpec{</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;  InitCallBack{[](InitContext &amp;setup){</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;      auto statefulGeo = std::make_shared&lt;TGeo&gt;();</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;      return [geo = statefulGeo](ProcessingContext &amp;) {</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        // do something with geo</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;      };</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;    }</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  }</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;}</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;```</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;### Task based API</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;The previous API is flexible enough to work for large variety of cases, including </div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;creating `onProcess` callback on the fly depending on the `onInit` parameters.</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;. </div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;However, very often what the user wants to do is to initialise some state and </div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;and invoke a &quot;run&quot; method. For this we provide a `Task` based API. In order to do so,</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;you need to inherit your task from `o2::framework::Task` and use the adaptor:</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;```cpp</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;adaptFromTask&lt;TASK&gt;(task constructor arguments) -&gt; AlgorithmSpec</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;```</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;to create the `AlgorithmSpec`. A full example can be found in</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;`Framework/Core/test/test_Task.cpp`</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;## Implementing a computation</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;This chapter describes how to actually implement an `AlgorithmSpec`.</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;### Using inputs - the `InputRecord` API</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;Inputs to your computation will be provided to you via the `InputRecord`. An instance of such a class is hanging from the `ProcessingContext` your computation lambda is passed and contains one value for each of the `InputSpec` you specified. E.g.:</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;```cpp</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;InputRecord &amp;inputs = ctx.inputs();</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;```</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;From the `InputRecord` instance you can get the arguments either via their positional index:</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;```cpp</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;DataRef ref = inputs.getByPos(0);</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;```</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;or using the mnemonics-label which was used as first argument in the associated `InputSpec`.</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;```cpp</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;DataRef ref = inputs.get(&quot;points&quot;);</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;```</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;You can then use the `DataRef` `header` and `payload` raw pointers to access the data in the messages.</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;If the message is of a known messageable type, you can automatically get the content of the message by passing type T as template argument. The actual operation depends on the properties of the type. Not all types are supported, in order to get an object with pointer-like behavior, T has to be a pointer (T = U*).</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;```cpp</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;auto p = args.get&lt;T&gt;(&quot;input&quot;);</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;```</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;The return type is</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;* `T const&amp;` if `T` is a messageable type</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;* `T` if `T` is a `std::container` of a ROOT-serializable type</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;* `smart_pointer&lt;T&gt;` if `T` is a ROOT-serializable type and `T*` is passed</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;Examples:</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;* for messageable types there is no additional copy involved, the content is only for reading.</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;```cpp</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;XYZ const&amp; p = args.get&lt;XYZ&gt;(&quot;points&quot;);</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;```</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;* ROOT-serialized objects are automatically deserialized and returned as a smart pointer. Note that the requested type has to be pointer.</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;```cpp</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;auto h = args.get&lt;TH1*&gt;(&quot;histo&quot;);</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;h-&gt;Print();</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;```</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;* container of ROOT-serialized objects are automatically deserialized and returned as container object.</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;```cpp</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;auto points = args.get&lt;std::vector&lt;TPoint&gt;&gt;(&quot;points&quot;);</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;for (auto&amp; point : points) {}</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;```</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;Check next section for known types. The framework will also take care of necessary deserialization.</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;### Creating outputs - the DataAllocator API</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;In order to prevent algorithms to create data they are not supposed to create, a special `DataAllocator` object is passed to the process callback, so that only messages for declared outputs can be created. A `DataAllocator` can create Framework owned resources via the `make&lt;T&gt;` method. In case you ask the framework to create a collection of objects, the result will be a `gsl::span` wrapper around the collection. A `DataAllocator` can adopt externally created resources via the `adopt` method. A `DataAllocator` can create a copy of an externally owned resource via the `snapshot` method.</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;Currently supported data types for `make&lt;T&gt;` are:</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;* Vanilla `char *` buffers with associated size:  this is the actual contents of the FairMQ message.</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;* Messageable types: trivially copyable, non-polymorphic types.</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  These get directly mapped on the message exchanged by FairMQ and are therefore &quot;zerocopy&quot; for what the Data Processing Layer is concerned.</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;* Collections of messageable types, exposed to the user as `gsl::span`.</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;* TObject derived classes. </div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  These are actually serialised via a TMessage and therefore are only suitable for the cases in which the cost of such a serialization is not an issue.</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;Currently supported data types for `snapshot` functionality, state at time of</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;calling `snapshot` is captured in a copy, and sent when processing is done:</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;* Messageable types.</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;* ROOT-serializable classes, serialised via a `TMessage`.</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  Classes implementing ROOT&#39;s `TClass` interface and std containers of those are automatically detected. ROOT-serialization can be forced using type converter `ROOTSerialized`, e.g. for types which can not be detected automatically</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;* `std::vector` of messageable type, at receiver side the collection is exposed as `gsl::span`.</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;* `std::vector` of pointers to messageable type, the objects are linearized in th message and exposed as gsl::span on the receiver side.</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;The `DataChunk` class resembles a `iovec`:</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;```cpp</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;struct DataChunk {</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  char *data;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;  size_t size;</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;};</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;```</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;however, no API is provided to explicitly send it. All the created DataChunks are sent (potentially using scatter / gather) when the `process` function returns. This is to avoid the “modified after send” issues where a message which was sent is still owned and modifiable by the creator.</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;### Error handling</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;When an error happens during processing of some data, the writer of the `process` function should simply throw an exception. By default the exception is caught by the `DataProcessingDevice` and a message is printed (if `std::exeception` derived `what()` method is used, otherwise a generic message is given). Users can provide themselves an error handler by specifying via the `onError` callback specified in `DataProcessorSpec`. This will allow in the future to reinject data into the flow in case of an error.</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;### Services</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;Services are utility classes which `DataProcessor`s can access to request out-of-bound, deployment dependent, functionalities. For example a service could be used to post metrics to the monitoring system or to get a GPU context. The former would be dependent on whether you are running on your laptop (where monitoring could simply mean print out metrics on the command line) or in a large cluster (where monitoring probably means to send metrics to an aggregator device which then pushes them to the backend.</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;Services are initialised by the driver code (i.e. the code included via `runDataProcessing.h`) and passed to the user code via a `ServiceRegistry`. You can retrieve the service by the type of its interface class. E.g. for Monitoring you can do:</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;```cpp</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;#include &lt;Monitoring/Monitoring.h&gt;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;// ...</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;auto service = ctx.services().get&lt;Monitoring&gt;(); // In the DataProcessor lambda...</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;service.send({ 1, &quot;my/metric&quot; }); ...</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;```</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;Currently available services are described below.</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;#### ControlService</div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;The control service allow DataProcessors to modify their state or the one of their peers in the topology. For example if you want to quit the whole data processing topology, you can use:</div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;</div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;```cpp</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;#include &quot;Framework/ControlService.h&quot;</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;//...</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;auto ctx.services().get&lt;ControlService&gt;().readyToQuit(QuitRequest::All) // In the DataProcessor lambda</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;```</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;#### RawDeviceService</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;This service allows you to get an hold of the `FairMQDevice` running the DataProcessor computation from with the computation itself. While in general this should not be used, it is handy in case you want to integrate with a pre-existing `FairMQDevice` which potentially does not even follow the O2 Data Model.</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;#### Monitoring service</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;Integration with the monitoring subsystem of O2 happens by getting the `o2::monitoring::Monitoring` interface. A simple example is:</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;```cpp</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;#include &lt;Monitoring/Monitoring.h&gt;</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;// ...</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;auto service = ctx.services().get&lt;Monitoring&gt;(); // In the DataProcessor lambda...</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;service.send({ 1, &quot;my/metric&quot; }); ...</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;```</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;for the full API documentation please have a look at:</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;https://github.com/AliceO2Group/Monitoring</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;Some suffix for the metrics are reserved to represent vector and tabular metrics.</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;* `&lt;some-metric-name&gt;/n` contains the size of a vector metric at a given moment.</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;* `&lt;some-metric-name&gt;/m` contains the secondary size of a matrix metric at a given moment.</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;* `&lt;some-metric-name&gt;/&lt;i&gt;` where `&lt;i&gt;` is an integer contains the values of the i-th element in a vector metric or of the `&lt;i&gt;%n` column, `&lt;i&gt;/m` row of a matrix metric.</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;#### Generic Logger</div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;Generic logging capabilities of DPL are provided via Framework/Logger which wraps and extents</div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;FairLogger.</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;```C++</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;#include &quot;Framework/Logger.h&quot;</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;...</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;LOG(INFO) &lt;&lt; &quot;some message&quot;;      // streamer based API</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;LOGF(INFO, &quot;%s&quot;, &quot;some message&quot;); // printf based API</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;LOGP(INFO, &quot;{}&quot;, &quot;some message&quot;); // python / fmt based API</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;O2INFO(&quot;{}&quot;, &quot;some message);      // same but with less typing.</div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;```</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;#### InfoLogger service</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;Integration with the InfoLogger subsystem of O2 happens in two way:</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;* Explicitly, by getting the `AliceO2::InfoLogger::InfoLogger` service from the registry, like done in the monitoring case:</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;```c++</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;#include &lt;InfoLogger/InfoLogger.hxx&gt;</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;//...</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;auto logger = context.services().get&lt;InfoLogger&gt;(); // In the DataProcessor lambda</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;```</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;* Implicitly, by using the standard FairLogger `LOG` macro. In order to enable this</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;  the user needs to specify the minimum severity to send to the `InfoLogger` via the</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  `--infologger-severity` option, e.g.:</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;```bash</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;... --infologger-severity WARNING</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;```</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;</div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;Finally, one can configure the bahavior of the InfoLogger by using the `--infologger-mode` option.</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;#### Callback service</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;A service that data processors can register callback functions invoked by the framework at defined steps in the process flow. This allows you to have customisation points for the following event:</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;</div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;* `CallbackService::Id::Start`: before entering the running state.</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;* `CallbackService::Id::Stop`: before exiting the running state.</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;* `CallbackService::Id::Reset`: before resetting the device.</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;Moreover in case you want to process events which are not coming from `FairMQ`, there is a `CallbackService::Id::ClockTick` which is called according to the rate specified for the backing FairMQ device.</div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;Similarly the `CallbackService::Id::Idle` callback is fired whenever there was nothing to process.</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;One last callback is `CallbackService::Id::EndOfStream`. This callback will be invoked whenever all the upstream DataProcessingDevice consider that they will not produce any more data, so we can finalize our results and exit.</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;## Expressing parallelism</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;If we want to retain a message passing semantic and really treat shared memory as yet another transport, we need to be very careful in how to express parallelism on data, so that the “single ownership model” of message passing forces us to either duplicate streams that need to be accessed in parallel, or to serialise workers which need to access the same data. Solutions like reference counting shared memory would not be allowed in such a scenario and in any case would require extra caution and support to make sure that failures do not leave dangling reference around (e.g. when one of the parallel workers abruptly terminates). First of all let’s consider the fact that there are two level of parallelisms which can be achieved:</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;* Data flow parallelism: when data can be split in partitions according to some subdivision criteria (e.g. have one stream per TPC sector and have one worker for each).</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;* Time flow parallelism: when parallelism can be achieved by having different workers handle different time intervals for the incoming data. (e.g. worker 0 processes even timeframes, worker 1 processes odd timeframes).</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;In order to express those DPL provides the `o2::framework::parallel` and `o2::framework::timePipeline` helpers to avoid expressing those explicitly in the workflow.</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;## Integrating with pre-existing devices</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;It can actually happen that you need to interface with native FairMQ devices, either for convenience or because they require a custom behavior which does not map well on top of the Data Processing Layer.</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;This is fully supported and the DPL provides means to ingest foreign, non-DPL `FairMQDevice` produced messages into a DPL workflow. This is done via the help of a &quot;proxy&quot; data processor which connects to the foreign device, receives its inputs, optionally converts them to a format understood by the Data Processing Layer, and then pumps them to the right Data Processor Specs. </div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;This is done using the `FairMQRawDeviceService` which exposes the actual device on which an Algorithm is running, giving the user full control.</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;## Customisation of default behavior</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;The DPL aims at solving with the default behavior the majority of common usecases. For all the special cases to be handle, we however provide multiple customisation entrypoints, in particular to:</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;* Change the policy for when an input record can be processed and what to do with the record afterwards. This is referred as `CompletionPolicy`.</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;* Change the behavior of the FairMQ channels. This is referred to as `ChannelConfigurationPolicy`.</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;* Change the command line options of the workflow driver.</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;In all cases this is done by providing a:</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;```cpp</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;void customize(...)</div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;```</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;free function which takes as argument the group of policies to be applied to customise the behavior.</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;## Managing multiple workflows.</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;</div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;In general a DPL workflow consists of a C++ executable which defines an</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;implicit workflow, as previously discribed. However it is sometimes handy</div><div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;to be able to split workflow in parts, e.g. to be able to run two detectors</div><div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;independently or to have a basic workflow with is then decorated with extra</div><div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;processing like data sampling if / when requested.</div><div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;</div><div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;DPL allows merging workflows by simply piping one into the other. So if `workflow-a`</div><div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;and `workflow-b` are two separate workflows, one can run the union of the two by doing:</div><div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div><div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;```bash</div><div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;workflow-a | workflow-b</div><div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;```</div><div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div><div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;Because the merging happens at the level of the implicit representation, this</div><div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;allows having dangling inputs and outputs which are potentially satisfied only</div><div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;when a separate workflow is merged.</div><div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;</div><div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;# Forward looking statements:</div><div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;</div><div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;## Support for analysis</div><div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;</div><div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;While not part of the initial design goal, we plan to extend DPL in order to support analysis. In particular we are evaluating a mode in which users can natively get a ROOT `RDataFrame` with an API similar to the `InputRecord` API.</div><div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div><div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;## Provenance dependent matching of inputs and outputs</div><div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;</div><div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;By default the Input and Outputs are matched solely by the signature of the data they contain. However sometimes it&#39;s desirable that this matching happens based on the history that a given message had, e.g. if it went through one path or another of a dataflow bifurcation. While this is not at the moment supported and you would have to use a separate data type for the two different origins, the usecase is acknowledged and will be addressed in a future revision of this document.</div><div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div><div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;## Support for non compiled, non C++, based configuration</div><div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;</div><div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;At the moment the configuration of a topology is done by compiling a declarative description of the computation done in C++, and by running the resulting executable. This is however an implementation detail and the datamodel for the configuration description is meant to be agnostic from the language. We foresee both using interpreted configurations (e.g. via ROOT / cling) or configurations done through another language (e.g. go, javascript).</div><div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;</div><div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;# Current Demonstrator</div><div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;</div><div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;A demonstrator illustrating a possible implementation of the design described above is now found in the dev branch of AliceO2, in the Framework folder.</div><div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;</div><div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;In particular:</div><div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div><div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;- `Framework/Core` folder contains the `DataProcessorSpec` class and related.</div><div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;- `Framework/Core/test` folder contains a few unit test and simple example workflows.</div><div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;- `Framework/TestWorkflows` folder contains a few example workflows.</div><div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;- `Framework/DebugGUI` folder contains the core GUI functionalities.</div><div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;- `Framework/Utils` folder contains utilities and helpers for the creation of workflows.</div><div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;</div><div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;There is also a few demonstrator available in particular:</div><div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;</div><div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;  - https://github.com/AliceO2Group/AliceO2/tree/dev/Detectors/TPC/workflow demonstrates the usage of DPL for TPC clusterisation and track reconstruction.</div><div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  - https://github.com/AliceO2Group/AliceO2/blob/dev/Framework/TestWorkflows/src/o2SyncReconstructionDummy.cxx provides a skeleton for the synchronous reconstruction.</div><div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;  - https://github.com/AliceO2Group/AliceO2/tree/dev/Steer/DigitizerWorkflow provides a workflow than can do TPC digitisation.</div><div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div><div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;</div><div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;## Interesting reads</div><div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;</div><div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;- [MillWheel: Fault-Tolerant Stream Processing at Internet Scale](https://research.google.com/pubs/pub41378.html) : paper about Google previous generation system for stream processing</div><div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;</div><div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;## Data Sampling</div><div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;</div><div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;Data Sampling provides possibility to sample data in DPL workflows, basing on certain conditions ( 5% randomly, when payload is greater than 4234 bytes, etc.). The job of passing the right data is done by a data processor called `Dispatcher`. A desired data stream is specified in form of Data Sampling Policies, configured by JSON structures (example below).</div><div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;```</div><div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;{</div><div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;  &quot;id&quot;: &quot;policy_example1&quot;,              # name of the policy</div><div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;  &quot;active&quot;: &quot;false&quot;,                    # activation flag</div><div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;  &quot;machines&quot;: [                         # list of machines where the policy should be run (now ignored)</div><div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;    &quot;aido2flp1&quot;,</div><div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;    &quot;aido2flp2&quot;</div><div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;  ],                                    # list of data that should be sampled, the format is:</div><div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;                                        # binding1:origin1/description1/subSpec1[;binding2:...]</div><div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;  &quot;query&quot;: &quot;clusters:TPC/CLUSTERS/0;tracks:TPC/TRACKS/0&quot;,</div><div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;  &quot;samplingConditions&quot;: [               # list of sampling conditions</div><div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;    {</div><div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;      &quot;condition&quot;: &quot;random&quot;,            # condition type</div><div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;      &quot;fraction&quot;: &quot;0.1&quot;,                # condition-dependent parameter: fraction of data to sample</div><div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;      &quot;seed&quot;: &quot;2112&quot;                    # condition-dependent parameter: seed of PRNG</div><div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;    }</div><div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;  ],</div><div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;  &quot;blocking&quot;: &quot;false&quot;                   # should the dispatcher block the main data flow? (now ignored)</div><div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;}</div><div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;```</div><div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;</div><div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;### Usage</div><div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;</div><div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;To use Data Sampling in a DPL workflow insert following lines to your code:</div><div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;```cpp</div><div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;#include &quot;Framework/DataSampling.h&quot;</div><div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;using namespace o2::framework;</div><div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;void customize(std::vector&lt;CompletionPolicy&gt;&amp; policies)</div><div class="line"><a name="l00501"></a><span class="lineno">  501</span>&#160;{</div><div class="line"><a name="l00502"></a><span class="lineno">  502</span>&#160;  DataSampling::CustomizeInfrastructure(policies);</div><div class="line"><a name="l00503"></a><span class="lineno">  503</span>&#160;}</div><div class="line"><a name="l00504"></a><span class="lineno">  504</span>&#160;</div><div class="line"><a name="l00505"></a><span class="lineno">  505</span>&#160;void customize(std::vector&lt;ChannelConfigurationPolicy&gt;&amp; policies)</div><div class="line"><a name="l00506"></a><span class="lineno">  506</span>&#160;{</div><div class="line"><a name="l00507"></a><span class="lineno">  507</span>&#160;  DataSampling::CustomizeInfrastructure(policies);</div><div class="line"><a name="l00508"></a><span class="lineno">  508</span>&#160;}</div><div class="line"><a name="l00509"></a><span class="lineno">  509</span>&#160;</div><div class="line"><a name="l00510"></a><span class="lineno">  510</span>&#160;#include &quot;Framework/runDataProcessing.h&quot;</div><div class="line"><a name="l00511"></a><span class="lineno">  511</span>&#160;</div><div class="line"><a name="l00512"></a><span class="lineno">  512</span>&#160;std::vector&lt;DataProcessorSpec&gt; defineDataProcessing(ConfigContext &amp;ctx)</div><div class="line"><a name="l00513"></a><span class="lineno">  513</span>&#160;{</div><div class="line"><a name="l00514"></a><span class="lineno">  514</span>&#160;</div><div class="line"><a name="l00515"></a><span class="lineno">  515</span>&#160; WorkflowSpec workflow;</div><div class="line"><a name="l00516"></a><span class="lineno">  516</span>&#160;// &lt;declaration of other DPL processors&gt;</div><div class="line"><a name="l00517"></a><span class="lineno">  517</span>&#160;</div><div class="line"><a name="l00518"></a><span class="lineno">  518</span>&#160; DataSampling::GenerateInfrastructure(workflow, &quot;json:///absolute/path/to/config/file.json&quot;);</div><div class="line"><a name="l00519"></a><span class="lineno">  519</span>&#160;</div><div class="line"><a name="l00520"></a><span class="lineno">  520</span>&#160; return workflow;</div><div class="line"><a name="l00521"></a><span class="lineno">  521</span>&#160;}</div><div class="line"><a name="l00522"></a><span class="lineno">  522</span>&#160;```</div><div class="line"><a name="l00523"></a><span class="lineno">  523</span>&#160;</div><div class="line"><a name="l00524"></a><span class="lineno">  524</span>&#160;Sampled data can be subscribed to by adding `InputSpecs` provided by `std::vector&lt;InputSpec&gt; DataSampling::InputSpecsForPolicy(const std::string&amp; policiesSource, const std::string&amp; policyName)` to a chosen data processor. Then, they can be accessed by the bindings specified in the configuration file. Dispatcher adds a `DataSamplingHeader` to the header stack, which contains statistics like total number of evaluated/accepted messages for a given Policy or the sampling time since epoch.</div><div class="line"><a name="l00525"></a><span class="lineno">  525</span>&#160;</div><div class="line"><a name="l00526"></a><span class="lineno">  526</span>&#160;[o2-datasampling-pod-and-root](https://github.com/AliceO2Group/AliceO2/blob/dev/Framework/TestWorkflows/src/dataSamplingPodAndRoot.cxx) workflow can serve as usage example.</div><div class="line"><a name="l00527"></a><span class="lineno">  527</span>&#160;</div><div class="line"><a name="l00528"></a><span class="lineno">  528</span>&#160;## Data Sampling Conditions</div><div class="line"><a name="l00529"></a><span class="lineno">  529</span>&#160;</div><div class="line"><a name="l00530"></a><span class="lineno">  530</span>&#160;The following sampling conditions are available. When more than one is used, a positive decision is taken when all the conditions are fulfilled.</div><div class="line"><a name="l00531"></a><span class="lineno">  531</span>&#160;- **DataSamplingConditionRandom** - pseudo-randomly accepts specified fraction of incoming messages.</div><div class="line"><a name="l00532"></a><span class="lineno">  532</span>&#160;```json</div><div class="line"><a name="l00533"></a><span class="lineno">  533</span>&#160;{</div><div class="line"><a name="l00534"></a><span class="lineno">  534</span>&#160;  &quot;condition&quot;: &quot;random&quot;,</div><div class="line"><a name="l00535"></a><span class="lineno">  535</span>&#160;  &quot;fraction&quot;: &quot;0.1&quot;,</div><div class="line"><a name="l00536"></a><span class="lineno">  536</span>&#160;  &quot;seed&quot;: &quot;22222&quot;</div><div class="line"><a name="l00537"></a><span class="lineno">  537</span>&#160;}</div><div class="line"><a name="l00538"></a><span class="lineno">  538</span>&#160;```</div><div class="line"><a name="l00539"></a><span class="lineno">  539</span>&#160;- **DataSamplingConditionNConsecutive** - approves n consecutive samples in defined cycle. It assumes that timesliceID always increments by one.</div><div class="line"><a name="l00540"></a><span class="lineno">  540</span>&#160;```json</div><div class="line"><a name="l00541"></a><span class="lineno">  541</span>&#160;{</div><div class="line"><a name="l00542"></a><span class="lineno">  542</span>&#160;  &quot;condition&quot;: &quot;nConsecutive&quot;,</div><div class="line"><a name="l00543"></a><span class="lineno">  543</span>&#160;  &quot;samplesNumber&quot;: &quot;3&quot;,</div><div class="line"><a name="l00544"></a><span class="lineno">  544</span>&#160;  &quot;cycleSize&quot;: &quot;100&quot;</div><div class="line"><a name="l00545"></a><span class="lineno">  545</span>&#160;}</div><div class="line"><a name="l00546"></a><span class="lineno">  546</span>&#160;```</div><div class="line"><a name="l00547"></a><span class="lineno">  547</span>&#160;- **DataSamplingConditionPayloadSize** - approves messages having payload size within specified boundaries.</div><div class="line"><a name="l00548"></a><span class="lineno">  548</span>&#160;```json</div><div class="line"><a name="l00549"></a><span class="lineno">  549</span>&#160;{</div><div class="line"><a name="l00550"></a><span class="lineno">  550</span>&#160;  &quot;condition&quot;: &quot;payloadSize&quot;,</div><div class="line"><a name="l00551"></a><span class="lineno">  551</span>&#160;  &quot;lowerLimit&quot;: &quot;300&quot;,</div><div class="line"><a name="l00552"></a><span class="lineno">  552</span>&#160;  &quot;upperLimit&quot;: &quot;500&quot;</div><div class="line"><a name="l00553"></a><span class="lineno">  553</span>&#160;}</div><div class="line"><a name="l00554"></a><span class="lineno">  554</span>&#160;```</div><div class="line"><a name="l00555"></a><span class="lineno">  555</span>&#160;- **DataSamplingConditionCustom** - loads a custom condition, which should inherit from DataSamplingCondition, from a specified library.</div><div class="line"><a name="l00556"></a><span class="lineno">  556</span>&#160;```json</div><div class="line"><a name="l00557"></a><span class="lineno">  557</span>&#160;{</div><div class="line"><a name="l00558"></a><span class="lineno">  558</span>&#160;  &quot;condition&quot;: &quot;custom&quot;,</div><div class="line"><a name="l00559"></a><span class="lineno">  559</span>&#160;  &quot;moduleName&quot;: &quot;QcExample&quot;,</div><div class="line"><a name="l00560"></a><span class="lineno">  560</span>&#160;  &quot;className&quot;: &quot;o2::quality_control_modules::example::ExampleCondition&quot;,</div><div class="line"><a name="l00561"></a><span class="lineno">  561</span>&#160;  &quot;customParam&quot;: &quot;value&quot;</div><div class="line"><a name="l00562"></a><span class="lineno">  562</span>&#160;}</div><div class="line"><a name="l00563"></a><span class="lineno">  563</span>&#160;```</div><div class="line"><a name="l00564"></a><span class="lineno">  564</span>&#160;## Document history</div><div class="line"><a name="l00565"></a><span class="lineno">  565</span>&#160;</div><div class="line"><a name="l00566"></a><span class="lineno">  566</span>&#160;* v0.9: proposal for approval at the O2 TB - 19th June 2018</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d8/d11/Framework_2Core_2README_8md.html">README.md</a></li>
    <li class="footer">Generated on Thu Jun 4 2020 09:30:20 for Project by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
